	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Generic Constants

; ---- COLORS
CONS_COLOR_BLACK  EQU $00
CONS_COLOR_RED    EQU $46
CONS_COLOR_ORANGE EQU $38
CONS_COLOR_YELLOW EQU $1E
CONS_COLOR_GREEN  EQU $C6
CONS_COLOR_BLUE   EQU $A6
CONS_COLOR_PURPLE EQU $64

CONS_COLOR_PINK   EQU $3C
CONS_COLOR_TEAL   EQU $8D
CONS_COLOR_CHART  EQU $CA
CONS_COLOR_GREY   EQU $E1
CONS_COLOR_WHITE  EQU $EF
; ---- COLORS in Relation to OBJECTS
CONS_COLOR_BLOCK_BACKGROUND EQU #CONS_COLOR_BLACK
CONS_COLOR_BORDERS          EQU #CONS_COLOR_TEAL

; ---- Joystick stuff
CONS_P0_STARTING_JOYSTICK_BYTE EQU %10000000
CONS_P1_STARTING_JOYSTICK_BYTE EQU %00001000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
;--------
; FLIP_BOOL
; Original author: Andy Garber
; Takes a memory address and flips it's value than stores it
; Assumes the Memory address value is 1 or 0
; usage: FLIP_BOOL SomeAddress
        MAC FLIP_BOOL
.MEMADDR     SET {1}
        lda .MEMADDR
        EOR #$01
        sta .MEMADDR
        ENDM
;--------
; LOAD_POINTER_WITH_DATA
; Original author: Andy Garber
; Loads a pointer with low byte than high byte address of data object
; usage: LOAD_POINTER_WITH_DATA pointer data
        MAC LOAD_POINTER_WITH_DATA
.POINTER      SET {1}
.DATA_BLOB    SET {2}
          lda #<.DATA_BLOB
          sta .POINTER
          lda #>.DATA_BLOB
          sta .POINTER+1
        ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80
        
; ---- Generic        
boolBase .byte
LineIdx  .byte
RowIdx   .byte
PF_Ptr	    .DS 2
PLAYER_Ptr  .DS 2
; ---- Playfield
CONS_LEFT_WALL         EQU #$26
CONS_RIGHT_WALL        EQU #$7B
CONS_TOP_WALL          EQU #00
CONS_TILE_HEIGHT       EQU #10
CONS_TILE_WIDTH        EQU #17 ; ONLY for collision
CONS_TILE_ROWS         EQU #11 ; Has to be 11 otherwise things go wiggity wiggity wiggity whack
CONS_TILE_COLS         EQU #5
CONS_TILE_MAX          EQU #CONS_TILE_ROWS * #CONS_TILE_COLS
     ;org $90
PF_BallStates_All     .DS #CONS_TILE_MAX
PF_BallStates_Current .DS #CONS_TILE_COLS+1 ; the +1 is for storing the background color. Performance thing.
PF_RowIndexes         .DS #CONS_TILE_ROWS

; ---- Player
CONS_LAUNCH_START_X EQU #CONS_LEFT_WALL+(3*13)
CONS_LAUNCH_START_Y EQU #CONS_TOP_WALL+(#CONS_TILE_HEIGHT*12)+0
CONS_PLAYER_HEIGHT  EQU #02
CONS_PLAYER_WIDTH   EQU #%11111111          ;#%11100000 --> 3 byte
CONS_PLAYER_SPEED_Y EQU #CONS_PLAYER_HEIGHT ;2 gives me 5 steps per 10
CONS_PLAYER_SPEED_X EQU #9                  ; 3 width 3 speed == 5 steps					                        
                                            ; 6 with 6 steps == 3 steps
                                            
CONS_PLAYER_STATE_AIMING          EQU #$00 ; In use
CONS_PLAYER_STATE_MOVING          EQU #$01 ; In use
CONS_PLAYER_STATE_COLLISION_CHECK EQU #$02 ; Not in use, in case we need time
CONS_PLAYER_STATE_COLLISION_SET   EQU #$03 ; not in use, in case we need time
; -- X
PlayerXPos        .DS 2
PlayerDirX        .byte
Tick_PlayerX_Step .DS 2 ; 0 == current, 1 == max
PlayerRow         .DS 2
; -- Y
PlayerYPos        .DS 2
PlayerDirY        .byte
Tick_PlayerY_Step .DS 2 ; 0 == current, 1 == max 
PlayerCol         .DS 2
; ---- Color
PlayerColor       .DS 3 ; 0 == current, 1 == next player, aka launcher color, 2 == next block for check
; ---- State
PlayerState  .byte
; ---- Misc
PlayerLauncherIdx .byte


; -- Debug stuff, used to add 2 bytes at end to see how much we are 
PF_TEMP         .DS 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment
	seg Code
        org $f000
Start
	CLEAN_START
        ; These are so I can see where we are writing too
        lda #$FE
        sta PF_TEMP
        lda #$FF
        sta PF_TEMP+1
        lda #CONS_COLOR_BORDERS
        sta COLUP1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetupLevel
	jsr spawnBallAtLauncher
        
        ; Set level data
        LOAD_POINTER_WITH_DATA PF_Ptr,PF_Level_Colors;; TODO this should be setup ONCE than forgotten!!
        ; PF_Level_Color
        ldx #CONS_TILE_MAX
blankLevelColrs_Colors
	lda #CONS_COLOR_BLOCK_BACKGROUND
        sta PF_BallStates_All,x
	dex
        bne blankLevelColrs_Colors  
        
        ; Set level data
        LOAD_POINTER_WITH_DATA PF_Ptr,PF_Level_Colors;; TODO this should be setup ONCE than forgotten!!
        ; PF_Level_Color
        ldy #$04
        ldx #CONS_TILE_MAX-(#CONS_TILE_COLS*6)-1
loadLevelData_Colors
	lda (PF_Ptr),y
        sta PF_BallStates_All,x
        dey
        bpl .repeatColors
        ldy #$04
.repeatColors
	dex
        bpl loadLevelData_Colors  
;;;        
;;; Set ROW indexes for our max tiles for better writing later.
	lda #CONS_TILE_MAX
        sta PF_RowIndexes
        ldy 0
        ldx #CONS_TILE_ROWS
loadRowIndex
	sec
        sbc #CONS_TILE_COLS
        sta PF_RowIndexes,y
        iny
        dex
        bne loadRowIndex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        lda #$01
        sta PlayerLauncherIdx        
        ;TODO -- more eligant start up
        lda #CONS_PLAYER_STATE_AIMING
        sta PlayerState
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
	jsr setXPositionsForObjects ; Does not need to be sub routine, just like the cleanliness
        nop
        TIMER_SETUP 37
        lda #CONS_COLOR_BLOCK_BACKGROUND
        lda #$01
        sta CTRLPF
        lda #CONS_COLOR_BLOCK_BACKGROUND
        sta COLUPF
        lda #%00000000
        sta PF0
        lda #%11111111
        sta PF1
        lda #%11111111
        sta PF2    
        sta LineIdx ; has to count UP
        
        lda #%11111111
        sta GRP1
        lda #%01110000
        sta NUSIZ1 
        lda #02
        sta ENAM1
        sta COLUBK
        
        TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OnScreen
	TIMER_SETUP 195;214 -- include overscan here.
;	ldy #02
;Kernal_Delay_Top
;	dey
;        sta WSYNC
;        bne Kernal_Delay_Top
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda PlayerColor
        sta COLUP0
        lda #CONS_TILE_ROWS-1
        sta RowIdx
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
Kernal_DrawBlocks_Row
	jsr setCurrentRowTileColors
        ldy #CONS_TILE_HEIGHT
Kernal_DrawBlocks_Col
        sta WSYNC
        lda LineIdx
        sec
        sbc PlayerYPos
        cmp #CONS_PLAYER_HEIGHT
        bcc .TurnOnPlayer
        lda #$00
	sta GRP0
        jmp .DrawPlayfield
.TurnOnPlayer
	lda #CONS_PLAYER_WIDTH
        sta GRP0
        jmp .nextLine
.DrawPlayfield
        REPEAT 2 ; max 3
          lda PF_BallStates_Current+5 ; does nothing but looks "better"
        REPEND  
        REPEAT 0 ; max 4
          nop 
        REPEND
        lda PF_BallStates_Current+0
        sta COLUPF
        lda PF_BallStates_Current+1
        sta COLUPF
        lda PF_BallStates_Current+2
        sta COLUPF       
        lda PF_BallStates_Current+3
        sta COLUPF
        lda PF_BallStates_Current+4
        sta COLUPF
        ; always black but for timing needs to be here!
        lda PF_BallStates_Current+5 
        sta COLUPF
.nextLine
	inc LineIdx
        dey
        bpl Kernal_DrawBlocks_Col
.nextSection
	dec RowIdx
        bpl Kernal_DrawBlocks_Row
ClearForLauncher
        lda #CONS_COLOR_BLACK
        sta COLUBK
        lda #$00
        sta PF0
        sta PF1
        sta PF2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #$10
Kernal_Gap_Under_Blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
        inc LineIdx
        lda LineIdx
        sec
        sbc PlayerYPos
        cmp #01
        bcc .TurnOnPlayer_2
        lda #$00
        jmp .nextLine_2
.TurnOnPlayer_2
	lda #$ff
.nextLine_2
        sta GRP0       
	dex
        bne Kernal_Gap_Under_Blocks
        nop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda PlayerColor+1
        sta COLUPF
        lda #%00100001
        sta CTRLPF
        ldy #CONS_TILE_HEIGHT ; must be this height!
Kernal_Launcher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC  
        lda #$02
        sta ENABL
	dey
        bne Kernal_Launcher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
        lda #$00
        sta GRP1
	sta ENAM1
        sta ENABL
        
        lda PlayerColor+1
        sta COLUPF
	ldy #$6
Kernal_Launcher_Base
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC    
        lda #$E0
        sta PF2
	dey
        bne Kernal_Launcher_Base      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_End
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda #CONS_COLOR_BLACK
        sta COLUPF        
        lda #$00
        sta GRP0

	lda PlayerState
        ;These will be needed if efficiency dies.
        ;cmp #CONS_PLAYER_STATE_COLLISION_CHECK
        ;beq .checkCollision
        cmp #CONS_PLAYER_STATE_MOVING
        beq .moveBall
        cmp #CONS_PLAYER_STATE_COLLISION_SET
        beq .setCollision
.readUserImport
        jsr MoveJoystick
        sta PlayerState
        jmp OffScreen
.moveBall
        jsr setBallPosition
        ;lda #CONS_PLAYER_STATE_COLLISION_CHECK
        ;jmp OffScreen
.checkCollision
	jsr getCollision
.checkIfNextBlockIsBlank
        lda PlayerColor+2
        cmp #CONS_COLOR_BLOCK_BACKGROUND
        beq .skipSetCollision
        lda #CONS_PLAYER_STATE_COLLISION_SET
        sta PlayerState
        jmp OffScreen
.skipSetCollision
	lda #CONS_PLAYER_STATE_MOVING
        sta PlayerState
	jmp OffScreen
.setCollision
	jsr setCollision
        ;jsr spawnBallAtLauncher ; should happen!! possible new state?
	lda #CONS_PLAYER_STATE_AIMING
        sta PlayerState
        ;jmp OffScreen ; TODO -- not needed but keeps things clean
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        nop
        TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 29 lines of overscan
	TIMER_SETUP 29;29
        nop
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC	; start a new line
        sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x	; fix coarse position
        sta HMP0,x	; set fine offset
        sta WSYNC
        sta HMOVE	; apply the previous fine position(s)
	sta HMCLR	; reset the old horizontal position(s)
        rts		; return to caller
;-----------------------------------------        
setXPositionsForObjects
        lda PlayerXPos   ; get X coordinate
        ldx #0           ; player 0
        jsr SetHorizPos  ; set coarse offset

   
        lda #CONS_LEFT_WALL-9   ; get X coordinate
        ldx #1
        jsr SetHorizPos
        
        ;TODO --- cannot use player 0 missle as a border, our color will change!!
        lda #CONS_RIGHT_WALL+10   ; get X coordinate
        ldx #3
        jsr SetHorizPos       
        
        lda #CONS_LAUNCH_START_X+3   ; get X coordinate
        ldx #4
        jsr SetHorizPos
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
        rts
;-----------------------------------------        
setCurrentRowTileColors
        ; get the row we will want to store it in current
        ldx RowIdx
        ldy PF_RowIndexes,x
	lda PF_BallStates_All,y
        sta PF_BallStates_Current
	lda PF_BallStates_All,y+1
        sta PF_BallStates_Current+1
	lda PF_BallStates_All,y+2
        sta PF_BallStates_Current+2
	lda PF_BallStates_All,y+3
        sta PF_BallStates_Current+3
	lda PF_BallStates_All,y+4
        sta PF_BallStates_Current+4
	lda #CONS_COLOR_BLOCK_BACKGROUND
        sta PF_BallStates_Current+5
        rts        
;-----------------------------------------
setBallPosition
	dec Tick_PlayerY_Step
        bne .stepXPosTick
        ldy Tick_PlayerY_Step+1
        sty Tick_PlayerY_Step
        sec
.changeYPos
        lda PlayerYPos
        sbc PlayerDirY
        sta PlayerYPos
        ;TODO -- vv this is actually something we need to REMOVE. just for testing!
        cmp #CONS_TOP_WALL
	bpl .stepXPosTick
        ;lda #00
        ;sta PlayerDirY
        lda #CONS_LAUNCH_START_Y
        sta PlayerYPos
        lda #CONS_PLAYER_STATE_AIMING
        sta PlayerState
        ;TODO -- ^^ this is actually something we need to REMOVE. just for testing!

;-----------------------------------------
.stepXPosTick
	dec Tick_PlayerX_Step
        bne .endBallPosition
        ldy Tick_PlayerX_Step+1
        sty Tick_PlayerX_Step
.changeXPos
        lda PlayerXPos
        clc
        adc PlayerDirX
.checkLeftBoundry
	cmp #CONS_LEFT_WALL
        bcs .checkRightBoundry
        lda #CONS_PLAYER_SPEED_X
        sta PlayerDirX
        lda #CONS_LEFT_WALL+#CONS_PLAYER_SPEED_X
        jmp .endXPosition
.checkRightBoundry
        cmp #CONS_RIGHT_WALL
        bcc .endXPosition
        lda #$00-CONS_PLAYER_SPEED_X
        sta PlayerDirX
        lda #CONS_RIGHT_WALL-#CONS_PLAYER_SPEED_X
.endXPosition
	sta PlayerXPos
.endBallPosition
        rts
;-----------------------------------------
getCollision
.checkRowCollision
        clc
        lda PlayerYPos
        ldy #$00
.findRowCurrent	
        sbc #CONS_TILE_HEIGHT
        bcc .storeRowCurrent
        iny
        jmp .findRowCurrent
.storeRowCurrent
	sty PlayerRow
        lda Tick_PlayerY_Step
        cmp #01
        bne .storeNextRow ; otherwise we skip to the COL stuff
        clc
        lda PlayerYPos
        sbc PlayerDirY
        clc
        ldy #$00
.findRowNext
        sbc #CONS_TILE_HEIGHT
        bcc .storeNextRow
        iny
        jmp .findRowNext
.storeNextRow
	sty PlayerRow+1
;-----
.checkColCollision
        clc
        lda PlayerXPos
        ldy #$00
.findColCurrent	 
        sbc #CONS_TILE_WIDTH
        cmp #CONS_LEFT_WALL
        bcc .storeColCurrent
        iny
        jmp .findColCurrent
.storeColCurrent
	sty PlayerCol
        lda Tick_PlayerX_Step
        cmp #01
        bne .storeNextCol ; otherwise we skip to the COL stuff
        clc
        lda PlayerXPos
        adc PlayerDirX
        clc
        ldy #$00
.findColNext
        sbc #CONS_TILE_WIDTH
        cmp #CONS_LEFT_WALL
        bcc .storeNextCol
        iny
        jmp .findColNext
.storeNextCol
	sty PlayerCol+1
.getNextColor
        clc
        tya
        ldy PlayerRow+1
	adc PF_RowIndexes,y
        lda PF_BallStates_All,y
        sta PlayerColor+2
	rts
;-----------------------------------------
;TODO -- i ought to be able to do this faster and IDK why I cant!
setCollision
        lda PlayerCol
        ldy PlayerRow
.multiplyByRow_Set
        cpy #00
        beq .setColorHere
        dey
        clc
	adc #CONS_TILE_COLS
        jmp .multiplyByRow_Set
.setColorHere        
        tay
	lda #CONS_COLOR_BLOCK_BACKGROUND;PlayerColor
        sta PF_BallStates_All,y
	rts 
;-----------------------------------------
spawnBallAtLauncher
        ; Set player colors
        lda #CONS_COLOR_GREEN
        sta PlayerColor
        lda #CONS_COLOR_TEAL
        sta PlayerColor+1
        lda #CONS_COLOR_BLOCK_BACKGROUND
        sta PlayerColor+2
        ; Set player Positions
	lda #CONS_LAUNCH_START_X
        ; Set Player Speeds (only the FIRST time... TODO -- move this!)
	sta PlayerXPos  
	;---------------
        lda #CONS_LAUNCH_START_Y
        sta PlayerYPos
        jsr setLauncher
	rts
setLauncher
	LOAD_POINTER_WITH_DATA PLAYER_Ptr,Launcher_Positions
        
        ldy PlayerLauncherIdx
        lda (PLAYER_Ptr),y
        sta Tick_PlayerX_Step
        sta Tick_PlayerX_Step+1
        iny
        lda (PLAYER_Ptr),y
        sta PlayerDirX
        iny
        lda (PLAYER_Ptr),y
        sta Tick_PlayerY_Step
        sta Tick_PlayerY_Step+1
        ; TODO not really necessary.....
        lda #CONS_PLAYER_SPEED_Y
        sta PlayerDirY
        rts
;-----------------------------------------
; SWCHA -- directional register
; #%10000000 -- P1 Right
; #%01000000 -- P1 left
; #%00100000 -- P1 down
; #%00010000 -- P1 up
; #%00001000 -- P0 Right
; #%00000100 -- P0 left
; #%00000010 -- P0 down
; #%00000001 -- P0 up
; 
MoveJoystick
      lda #%01000000
      bit SWCHA           ; Read Joystick directions
      bne .checkRight     ; If 0, Left is pressed
      dec PlayerLauncherIdx
.checkRight    
      lda #%10000000
      bit SWCHA      ; Mask for Bit 7
      bne .checkbutton        ; If 0, Right is pressed
      inc PlayerLauncherIdx
      ;TODO -- add something here where if we are moving, do NOT check button presses but allow aiming?
.checkbutton
      lda #%10000000              ; Load the state of the P1 button into the accumulator (A)
      bit INPT4       ; Test bit 7 of the accumulator.
      bpl .changeStateOnButton           ; If BIT 7 is 1 (Negative), button is released
      lda #CONS_PLAYER_STATE_AIMING
      jmp .endJoystickCheck
.changeStateOnButton
      lda #CONS_PLAYER_STATE_MOVING
.endJoystickCheck
      rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	align $100
PF_Level_Colors
	.byte #CONS_COLOR_RED
        .byte #CONS_COLOR_ORANGE
        .byte #CONS_COLOR_YELLOW
        .byte #CONS_COLOR_GREEN
        .byte #CONS_COLOR_PURPLE
        .byte #CONS_COLOR_BLUE
Launcher_Positions
	; PlayerXTicks | PlayerXSpeed (aka dir) | PlayerYTicks 
        .byte #$01,#$00-CONS_PLAYER_SPEED_X,#$03 ; Left Center 3
        .byte #$02,#$00-CONS_PLAYER_SPEED_X,#$02 ; Left Center 2
        .byte #$03,#$00-CONS_PLAYER_SPEED_X,#$01 ; Left Center 1
        .byte #$00,#$00,#$01                     ; Center
        .byte #$03,#CONS_PLAYER_SPEED_X,#$01     ; Right Center 1
        .byte #$02,#CONS_PLAYER_SPEED_X,#$02     ; Right Center 2
        .byte #$01,#CONS_PLAYER_SPEED_X,#$03     ; Right Center 3
        
;-----------------------------------------
;PF_Boundries_Row
;	.byte #(CONS_TILE_HEIGHT)*1
;        .byte #(CONS_TILE_HEIGHT)*2
;        .byte #(CONS_TILE_HEIGHT)*3
;        .byte #(CONS_TILE_HEIGHT)*4
;        .byte #(CONS_TILE_HEIGHT)*5
;        .byte #(CONS_TILE_HEIGHT)*6
;        .byte #(CONS_TILE_HEIGHT)*7
;        .byte #(CONS_TILE_HEIGHT)*8
;        .byte #(CONS_TILE_HEIGHT)*9
;        .byte #(CONS_TILE_HEIGHT)*10
;        .byte #(CONS_TILE_HEIGHT)*11
;        .byte #(CONS_TILE_HEIGHT)*12
;PF_Boundries_Col
;	.byte #(CONS_LEFT_WALL+17)
;        .byte #(CONS_LEFT_WALL+35)
;        .byte #(CONS_LEFT_WALL+53)
;        .byte #(CONS_LEFT_WALL+71)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector