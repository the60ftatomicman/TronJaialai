	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants
CONS_TILE_HEIGHT    EQU  #9
CONS_TILE_WIDTH     EQU  #18 ; ONLY for collision
CONS_TILE_ROWS      EQU  #11
CONS_TILE_COLS      EQU  #5
CONS_TILE_MAX       EQU  #CONS_TILE_ROWS * #CONS_TILE_COLS
CONS_PLAYER_HEIGHT  EQU #02
CONS_PLAYER_SPEED_Y EQU #01
CONS_PLAYER_SPEED_X EQU #01
; ---- COLORS
CONS_COLOR_BLACK  EQU $00
CONS_COLOR_RED    EQU $46
CONS_COLOR_ORANGE EQU $38
CONS_COLOR_YELLOW EQU $1E
CONS_COLOR_GREEN  EQU $C6
CONS_COLOR_BLUE   EQU $A6
CONS_COLOR_PURPLE EQU $64

CONS_COLOR_PINK   EQU $3C
CONS_COLOR_TEAL   EQU $8D
CONS_COLOR_CHART  EQU $CA
CONS_COLOR_GREY   EQU $E1
CONS_COLOR_WHITE  EQU $EF
; ---- COLORS in Relation to OBJECTS
CONS_COLOR_BLOCK_BACKGROUND EQU #CONS_COLOR_BLACK
CONS_COLOR_LAUNCHER_BASE    EQU #CONS_COLOR_TEAL

; ---- TIMERS
CONS_FRAME_ANIMATION_COUNTER EQU $03
; ---- BORDERS
CONS_LEFT_WALL    EQU #$25
CONS_RIGHT_WALL   EQU #$7A
CONS_TOP_WALL     EQU #00
CONS_LAUNCH_START EQU #CONS_LEFT_WALL+(CONS_TILE_WIDTH*3)

CONS_P0_STARTING_JOYSTICK_BYTE EQU %10000000
CONS_P1_STARTING_JOYSTICK_BYTE EQU %00001000
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
; TODO add to includes
;--------
; FLIP_BOOL
; Original author: Andy Garber
; Takes a memory address and flips it's value than stores it
; Assumes the Memory address value is 1 or 0
; usage: FLIP_BOOL SomeAddress
        MAC FLIP_BOOL
.MEMADDR     SET {1}
        lda .MEMADDR
        EOR #$01
        sta .MEMADDR
        ENDM
;--------
; CLEAR_PLAYFIELD
; Original author: Andy Garber
; sets playfield to 0 across the board
; usage: CLEAR_PLAYFIELD
        MAC CLEAR_PLAYFIELD
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        ENDM
;--------
; LOAD_POINTER_WITH_DATA
; Original author: Andy Garber
; Loads a pointer with low byte than high byte address of data object
; usage: LOAD_POINTER_WITH_DATA pointer data
        MAC LOAD_POINTER_WITH_DATA
.POINTER      SET {1}
.DATA_BLOB    SET {2}
          lda #<.DATA_BLOB
          sta .POINTER
          lda #>.DATA_BLOB
          sta .POINTER+1
        ENDM
;--------
; MOVE_PLAYER duration
; Original author: Andy Garber
; Moves the player
; useage: MOVE_PLAYER $0,CONS_BOUNDRY_P0_LEFT,CONS_BOUNDRY_P0_RIGHT,CONS_P0_STARTING_JOYSTICK_BYTE
        MAC MOVE_PLAYER
.PLAYEROFFSET      SET {1}
.LEFT_BOUNDRY      SET {2}
.RIGHT_BOUNDRY     SET {3}
.STARTING_JOYSTICK SET {4}
        ldx $01
        lda #.RIGHT_BOUNDRY
        sta horizontalBoundries
        lda #.LEFT_BOUNDRY
        sta horizontalBoundries,x
        lda #.STARTING_JOYSTICK
        ldy #.PLAYEROFFSET
	jsr MoveJoystick
        ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80
shadowRegisters   .DS 3
boolDraw          .byte
boolBase          .byte

LineIdx           .byte
RowIdx            .byte


Tick_LauncherAnim .byte
; used to determine when we do a step
Tick_PlayerX_Step .DS 2 ; 0 == current, 1 == max
Tick_PlayerY_Step .DS 2 ; 0 == current, 1 == max 

PlayerXPos   .DS 2; may need to make 1......
PlayerYPos   .DS 2

PlayerRow    .byte
PlayerCol    .byte

PlayerDirX   .byte
PlayerDirY   .byte

PF_Ptr	     .DS 2

	;org $90
PF_BallStates_All     .DS #CONS_TILE_MAX
PF_BallStates_Current .DS #CONS_TILE_COLS+1
	;org $E0
PF_RowIndexes         .DS #CONS_TILE_ROWS

END_USED_RAM .byte ; for debuggin!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment
	seg Code
        org $f000
Start
	CLEAN_START
        ldx #$00

        ; Set player positions
        lda #108
        sta PlayerYPos
	lda #CONS_LEFT_WALL
        ;#CONS_LAUNCH_START
	sta PlayerXPos
        lda #CONS_PLAYER_SPEED_X
        sta PlayerDirX
        lda #02
        sta Tick_PlayerX_Step
        sta Tick_PlayerX_Step+1 ; TODO -- joystick will update BOTH of these!
        lda #CONS_PLAYER_SPEED_Y
        sta PlayerDirY
        lda #01
        sta Tick_PlayerY_Step
        sta Tick_PlayerY_Step+1 ; TODO -- joystick will update BOTH of these!
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
; 37 lines of underscan
	;lda #$FF
        ;sta END_USED_RAM
        ;nop
	; Set player colors
	lda #CONS_COLOR_TEAL
        sta COLUP0
        lda #CONS_COLOR_TEAL
        sta COLUP1
        lda #00
        sta VDELP0	; if 1,updates to GRP0 will be delayed
              
	TIMER_SETUP 37
        ; Set level data
        LOAD_POINTER_WITH_DATA PF_Ptr,PF_Level_Colors
        ;; TODO this should be setup ONCE than forgotten!!
        ; PF_Level_Color
        ldy #$04
        ldx #CONS_TILE_MAX-1
loadLevelData_Colors
	lda (PF_Ptr),y
        sta PF_BallStates_All,x
        dey
        bpl .repeatColors
        ldy #04
.repeatColors
	dex
        bpl loadLevelData_Colors  
;;;        
;;; Set ROW indexes for our max tiles for beter writing later.
	lda #CONS_TILE_MAX
        sta PF_RowIndexes
        ldy 1
        ldx #CONS_TILE_ROWS
loadRowIndex
	clc
        sbc #CONS_TILE_COLS-1
        sta PF_RowIndexes,y
        iny
        dex
        bne loadRowIndex
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_Movement
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; This is where we do player X logic
	sta WSYNC
        lda PlayerXPos   ; get X coordinate
        ldx #0           ; player 0
        jsr SetHorizPos  ; set coarse offset

        lda PlayerXPos+1 ; get X coordinate
        ldx #1           ; player 1
        jsr SetHorizPos  ; set coarse offset
        
        lda #CONS_LAUNCH_START+4   ; get X coordinate
        ldx #4
        jsr SetHorizPos
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
       
        TIMER_WAIT
OnScreen
	TIMER_SETUP 195
        lda #CONS_COLOR_BLOCK_BACKGROUND
        sta COLUBK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        lda #$01
        sta CTRLPF
        lda #CONS_COLOR_BLOCK_BACKGROUND
        sta COLUPF
        lda #%00000000
        sta PF0
        lda #%11111111
        sta PF1
        lda #%11111111
        sta PF2    
        sta LineIdx ; has to count UP

        lda #CONS_TILE_ROWS
        sta RowIdx
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
Kernal_DrawBlocks_Row
	jsr setCurrentRowTileColors
        ldy #CONS_TILE_HEIGHT
Kernal_DrawBlocks_Col
        sta WSYNC
        lda LineIdx
        sec
        sbc PlayerYPos
        cmp #CONS_PLAYER_HEIGHT
        bcc .TurnOnPlayer
        lda #$00
	sta GRP0
        jmp .DrawPlayfield
.TurnOnPlayer
	lda #%11110000
        sta GRP0
        jmp .nextLine
.DrawPlayfield
        REPEAT 3
        	nop
        REPEND
        lda PF_BallStates_Current+0
        sta COLUPF
        lda PF_BallStates_Current+1
        sta COLUPF
        lda PF_BallStates_Current+2
        sta COLUPF       
        lda PF_BallStates_Current+3
        sta COLUPF
        lda PF_BallStates_Current+4
        sta COLUPF
        ; always black but for timing needs to be here!
        lda PF_BallStates_Current+5 
        sta COLUPF
.nextLine
	inc LineIdx
        dey
        bpl Kernal_DrawBlocks_Col
.nextSection
	dec RowIdx
        bpl Kernal_DrawBlocks_Row
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        lda #CONS_COLOR_BLACK
        sta COLUBK
        lda #$00
        sta PF0
        sta PF1
        sta PF2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #$10
Kernal_Gap_Under_Blocks
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
        inc LineIdx
        lda LineIdx
        sec
        sbc PlayerYPos
        cmp #CONS_PLAYER_HEIGHT
        bcc .TurnOnPlayer_2
        lda #$00
        jmp .nextLine_2
.TurnOnPlayer_2
	lda #$ff
.nextLine_2
        sta GRP0       
	dex
        bne Kernal_Gap_Under_Blocks
        nop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda #CONS_COLOR_LAUNCHER_BASE
        sta COLUPF
        lda #%00100001
        sta CTRLPF
        ldy #15
Kernal_Launcher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC  
        lda #$02
        sta ENABL
	dey
        bne Kernal_Launcher
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
        lda #$00
        sta ENABL
        lda #CONS_COLOR_LAUNCHER_BASE
        sta COLUPF
        lda Tick_LauncherAnim
        cmp #$00
        bne .pickLauncherFrame
        FLIP_BOOL boolBase
        lda #$06
        sta Tick_LauncherAnim
.pickLauncherFrame
	dec Tick_LauncherAnim 
        lda boolBase
        cmp #$00
        bne .drawA
        LOAD_POINTER_WITH_DATA PF_Ptr,PF_Launcher_Base_B
        ldy #$08
        jmp Kernal_Launcher_Base
.drawA
        LOAD_POINTER_WITH_DATA PF_Ptr,PF_Launcher_Base_A
	ldy #$08
Kernal_Launcher_Base
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
        lda (PF_Ptr),y
        sta PF2
	REPEAT 20
       		nop
        REPEND
        lda #%00000000
        sta PF2
	dey
        bne Kernal_Launcher_Base      
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_End
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	lda #CONS_COLOR_BLACK
        sta COLUPF        
        lda #$00
        sta GRP0
        sta GRP1
        jsr setBallPosition
        jsr checkCollision
	sta WSYNC ;; for DEBUG
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 29 lines of overscan
	TIMER_SETUP 29
        ;For demo purposes
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC	; start a new line
        sec		; set carry flag
DivideLoop
	sbc #15		; subtract 15
	bcs DivideLoop	; branch until negative
	eor #7		; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x	; fix coarse position
        sta HMP0,x	; set fine offset
        sta WSYNC
        sta HMOVE	; apply the previous fine position(s)
	sta HMCLR	; reset the old horizontal position(s)
        rts		; return to caller
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
setCurrentRowTileColors
        ; get the row we will want to store it in current
        ldx RowIdx
        ldy PF_RowIndexes,x
	lda PF_BallStates_All,y
        sta PF_BallStates_Current
	lda PF_BallStates_All,y+1
        sta PF_BallStates_Current+1
	lda PF_BallStates_All,y+2
        sta PF_BallStates_Current+2
	lda PF_BallStates_All,y+3
        sta PF_BallStates_Current+3
	lda PF_BallStates_All,y+4
        sta PF_BallStates_Current+4
	lda #CONS_COLOR_BLACK
        sta PF_BallStates_Current+5
        rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
setBallPosition
	dec Tick_PlayerY_Step
        bne .stepXPosTick
        ldy Tick_PlayerY_Step+1
        sty Tick_PlayerY_Step
.changeYPos
        lda PlayerYPos
        sec
        sbc PlayerDirY
        sta PlayerYPos
.stepXPosTick
	dec Tick_PlayerX_Step
        bne .endBallPosition
        ldy Tick_PlayerX_Step+1
        sty Tick_PlayerX_Step
.changeXPos
        lda PlayerXPos
        clc
        adc PlayerDirX
.checkLeftBoundry
	cmp #CONS_LEFT_WALL
        bcs .checkRightBoundry
        lda #CONS_PLAYER_SPEED_X
        sta PlayerDirX
        lda #CONS_LEFT_WALL
        jsr .endXPosition
.checkRightBoundry
        cmp #CONS_RIGHT_WALL
        bcc .endXPosition
        lda #$00-CONS_PLAYER_SPEED_X
        sta PlayerDirX
        lda #CONS_RIGHT_WALL
.endXPosition
	sta PlayerXPos
.endBallPosition
        rts
        
checkCollision
	ldy #$FF
	lda PlayerYPos
.getRowValue
	iny
        sec 
        sbc #CONS_TILE_HEIGHT
        bpl .getRowValue
        nop
        
	ldx #$FF
	lda PlayerXPos
.getColValue
	inx
        sec
        sbc #CONS_TILE_WIDTH
        cmp #CONS_LEFT_WALL
        bpl .getColValue
        nop
	rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	align $100
PF_Level_Colors
	.byte #CONS_COLOR_RED
        .byte #CONS_COLOR_ORANGE
        .byte #CONS_COLOR_YELLOW
        .byte #CONS_COLOR_GREEN
        .byte #CONS_COLOR_BLUE
        .byte #CONS_COLOR_PURPLE  
PF_Launcher_Base_A
	.byte #%00000000
	.byte #%11111111
        .byte #%11111111
        .byte #%11011001
        .byte #%11011001
        .byte #%11010101
        .byte #%10010011
        .byte #%10010011
        .byte #%10011111
PF_Launcher_Base_B
	.byte #%00000000
	.byte #%11111111
        .byte #%11111111
        .byte #%11010011
        .byte #%11010011
        .byte #%11010101
        .byte #%10011001
        .byte #%10011001
        .byte #%10011111        
	align $200
PF_Level_data
	; Level 1-----------------------------------------------------;
	.byte #%00000000 ; 0
        		 ; Colors total       == second 3 bytes
        		 ; How many rows down == first  4 bytes
        .byte #%11110000 ; 1
        		 ; Probability the connecting randomized blob
                         ; is the same as it's neighbor == first 4
                         ; probability modifier == second 4
        ;------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector