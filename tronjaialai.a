;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Header
        processor 6502
        include "vcs.h"
        include "macro.h"
        ; include "custom_macro.h" ; -- do so much work online this seems nice but necessary atm
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants
CONS_PLAYER_HEIGHT  EQU  $F2 ; FF-intended height
CONS_TILE_HEIGHT    EQU  #15
CONS_TILE_HIDE      EQU  %00000000

CONS_COLOR_BLACK EQU $00
CONS_COLOR_RED   EQU $40
CONS_COLOR_PINK  EQU $4A
CONS_COLOR_BLUE  EQU $82
CONS_COLOR_TEAL  EQU $8D
CONS_COLOR_GREEN EQU $C6
CONS_COLOR_CHART EQU $CA

CONS_FRAME_ANIMATION_COUNTER EQU $03

CONS_BOUNDRY_P0_LEFT  EQU #23
CONS_BOUNDRY_P0_RIGHT EQU #64
CONS_BOUNDRY_P1_LEFT  EQU #98
CONS_BOUNDRY_P1_RIGHT EQU #146
CONS_BOUNDRY_TOP      EQU #00
CONS_BOUNDRY_BOTTOM   EQU #29
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
; TODO add to includes
;--------
; FLIP_BOOL duration
; Original author: Andy Garber
; Takes a memory address and flips it's value than stores it
; Assumes the Memory address value is 1 or 0
;usage: FLIP_BOOL SomeAddress
        MAC FLIP_BOOL
.MEMADDR     SET {1}
        lda .MEMADDR
        EOR #$01
        sta .MEMADDR
        ENDM
;--------
; CLEAR_PLAYFIELD duration
; Original author: Andy Garber
; sets playfield to 0 across the board
        MAC CLEAR_PLAYFIELD
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        ENDM
        
;--------
; FILL_PLAYFIELD duration
; Original author: Andy Garber
; sets playfield to 1 across the board
        MAC FILL_PLAYFIELD
        lda #%11111111
        sta PF0
        sta PF1
        sta PF2
        ENDM
        
;--------
; DRAW_PLAYER duration
; Original author: Andy Garber
; Draws a player based on the lineIdx var
        MAC DRAW_PLAYER
.YPOS        SET {1}
.HEIGHT      SET {2}
.PLAYER_REG  SET {3}
.PLAYER_PTR  SET {4}
.PLAYER_IDX  SET {5}
	ldy .PLAYER_IDX
        lda .YPOS
        SBC LineIdx
        BPL .skip
        CMP #.HEIGHT
        BMI .skip
        lda (.PLAYER_PTR),y
        inc .PLAYER_IDX
        jmp .end
.skip
        lda #%0000000
.end   
        sta .PLAYER_REG
        ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Variables segment
        seg.u Variables
        org $80

DrawCycle       .byte ;-- what cycle of our draws we are on
                      ; 1: Draw playfield
                      ; 2: Draw Players
DrawPlayer      .byte ;-- what cycle of our draws we are on
                      ; 1: Draw playfield
                      ; 2: Draw Players
ReadJoystick    .byte

LineIdx         .byte

loopIntI        .byte
loopIntJ        .byte
loopIntK        .byte

p0_TileBooleans .DS 6
p1_TileBooleans .DS 6

P0XPos          .byte ;-- X coordinates
P1XPos          .byte

P0YPos          .byte ;-- Y coordinate (offset from the start of the playfield)
P1YPos          .byte

P0Idx           .byte ;-- data index of our sprite data
P1Idx           .byte

P0CIdx          .byte ;-- color index of our sprite data
P1CIdx          .byte

P0FrameIdx      .byte ;--- animation frame
P0FrameCounter  .byte ;--- frame counter

P0Ptr		.DS 2
P1Ptr		.DS 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment
        seg Code
        org $f000

Start
        CLEAN_START
        
        ldx #05
init_PF_Tiles
        lda #CONS_COLOR_BLUE
        sta p0_TileBooleans,x
        sta p1_TileBooleans,x
        dex
        bpl init_PF_Tiles
        lda #$01
        sta CTRLPF
        ;lda #CONS_COLOR_BLACK ; for debug
        ;sta p0_TileBooleans+5
        ;sta p1_TileBooleans+1
init_Players        
        lda #CONS_BOUNDRY_P0_LEFT  ; Max Left
        sta P0XPos
        lda #CONS_BOUNDRY_P1_RIGHT ; Max right
        sta P1XPos
        lda #CONS_BOUNDRY_TOP+3
        sta P0YPos
        sta P1YPos
        lda #0
        sta P0Idx
        sta P1Idx
        lda #CONS_FRAME_ANIMATION_COUNTER
        sta P0FrameCounter

        lda #<P0_Frame_0; I flipped this
        sta P0Ptr
        lda #>P0_Frame_0; I flipped this
        sta P0Ptr+1
        
        lda #<P1_Frame_0; I flipped this
        sta P1Ptr
        lda #>P0_Frame_0; I flipped this
        sta P1Ptr+1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Main
NextFrame
        lsr SWCHB ; test Game Reset switch
        bcc Start ; reset?
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_PreScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        VERTICAL_SYNC  ; 1 + 3 lines of VSYNC
        TIMER_SETUP 37 ; 37 lines of underscan

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Screen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
        CLEAR_PLAYFIELD
        lda #CONS_COLOR_PINK
        sta COLUP0
        lda #CONS_COLOR_CHART
        sta COLUP1
        lda #CONS_COLOR_BLACK
        sta COLUBK
        lda #255
        sta LineIdx
        


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;               Main (192 lines)
; What is a Kernal?
; These are groupings of line sections.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_Movement
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; This is where we do player X logic
; Set Player 1 x position
        lda P0XPos      ; get X coordinate
        ldx #0          ; player 0
        jsr SetHorizPos ; set coarse offset

        lda P1XPos      ; get X coordinate
        ldx #1          ; player 1
        jsr SetHorizPos ; set coarse offset
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
        
        lda #0
        sta P0Idx
        sta P1Idx
        TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         
        sta WSYNC
Kernal_Tower
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Background art for the upper half of the game.
; PF is set to Mirror and we just draw. than wait
; The BLACK we see is really the PF mirroed.
; Color of the towers is controlled by the background.
; TODO make this less gross.
        lda #CONS_COLOR_BLACK ; Make this a define
        sta COLUPF
	; These are ALWAYS the same
        lda #%11110000
        sta PF0  
        lda #%01111111 
       	sta PF2
        
        ldx #$0
        ldy #$48
        sta WSYNC
Kernal_Tower_Draw
	sta WSYNC
        tya
        cmp #$40
        bmi Kernal_Tower_WaitASecond
        lda PF_Kernal_Tower,x+1
        sta PF1
        jmp Kernal_Tower_Draw_Colorize
Kernal_Tower_WaitASecond
        lda #%11110111
        sta PF1
Kernal_Tower_Draw_Colorize   
        lda #CONS_COLOR_RED
        sta COLUBK
        SLEEP 16 ;; as we add more code for playfield, edit this.
        lda #CONS_COLOR_TEAL
        sta COLUBK      
        SLEEP 8 
        lda #CONS_COLOR_GREEN
        sta COLUBK
        inx
        inx
        inx
        dey
        bne Kernal_Tower_Draw
Kernal_Tower_End
	;TIMER_SETUP 48
        ;TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
        lda #CONS_COLOR_BLACK
        sta COLUBK
	CLEAR_PLAYFIELD
        lda #CONS_COLOR_BLUE ; Make this a define
        sta COLUPF
        ldx #2 ; this will always do +1 what you want
        stx loopIntI
        lda #%11110000
Kernal_Stairs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This draws a nice staircase from our tower
; More background mumbo jumbo
; TODO -- allow drawing of player here
        ldx #3 ; this will always do +1 what you want
        stx loopIntJ
Kernal_Stairs_J
        sta WSYNC
        sta PF2
        DEC loopIntJ
        BPL Kernal_Stairs_J
        LSR
        LSR
        DEC loopIntI
        BPL Kernal_Stairs
        sta WSYNC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Gap
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is just a spacing between the tiles
; we setup the presets for the complex stuff below!
; Maybe just make this part of the loop below? make my tile horizontal breaks 2 cycles each?

        CLEAR_PLAYFIELD
        sta WSYNC
        lda #CONS_COLOR_BLACK ; May NEVER need to do this, there may be an inverse for the stairs above.
        sta COLUPF

        
        lda #%01110000
        sta PF0
        lda #%000000100
        sta PF1
        lda #%11110000
        sta PF2
        
        lda #0
        sta LineIdx
        lda #3 ; this will always do +1 what you want
        sta loopIntI
        ldx #0 ; uused to change address levels
        
        sta WSYNC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_CombatField
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        lda CONS_TILE_HEIGHT
        sta loopIntJ
Kernal_CombatField_startOfDraw
        sta WSYNC
        
Kernal_CombatField_DrawPlayfied

        lda p0_TileBooleans,x
        sta COLUBK 
        
        SLEEP 21
        
        lda p0_TileBooleans,x+1
        sta COLUBK
        
        SLEEP 5 ; minimal. mid is red atm.
        

        lda p1_TileBooleans,x
	sta COLUBK
        
        SLEEP 10
        

       	lda p1_TileBooleans,x+1
        sta COLUBK

	SLEEP 4

        lda #CONS_COLOR_BLACK
	sta COLUBK
        
Kernal_CombatField_DrawPlayers
	
        DRAW_PLAYER P0YPos, CONS_PLAYER_HEIGHT, GRP0, P0Ptr,P0Idx
	DRAW_PLAYER P1YPos, CONS_PLAYER_HEIGHT, GRP1, P1Ptr,P1Idx
        
Kernal_CombatField_EndOfDraw
        inc LineIdx
        dec loopIntJ
        bne Kernal_CombatField_startOfDraw
        
	sta WSYNC
        inx
        inx
        dec loopIntI
        bne Kernal_CombatField
        
	jsr MoveJoystick
        nop ;DEBUG! til i fill this out
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 29 lines of overscan
Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        TIMER_SETUP 29
        TIMER_WAIT
        nop ; for debugging!
        ; total = 262 lines, go to next frame
        jmp NextFrame
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutines
;;;;;;;;;;;;;;;;;;;;;
; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC        ; start a new line
        sec               ; set carry flag
DivideLoop
        sbc #15          ; subtract 15
        bcs DivideLoop   ; branch until negative
        eor #7           ; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x      ; fix coarse position
        sta HMP0,x       ; set fine offset
        rts              ; return to caller
;;;;;;;;;;;;;;;;;;;;;
; TODO -- cannot handle double motion!
MoveJoystick
	ldx P0YPos
	lda #%00100000	;Down?
	bit SWCHA
	bne SkipMoveDown
        cpx #CONS_BOUNDRY_BOTTOM
        bcs SkipMoveDown
        inx
        dec P0FrameCounter
SkipMoveDown
	lda #%00010000	;Up
	bit SWCHA 
	bne SkipMoveUp
        cpx #CONS_BOUNDRY_TOP
        beq SkipMoveUp
        dex
        dec P0FrameCounter
SkipMoveUp
	stx P0YPos
; Move horizontally
        ldx P0XPos
	lda #%01000000	;Left?
	bit SWCHA
	bne SkipMoveLeft
        cpx #CONS_BOUNDRY_P0_LEFT
        bcc SkipMoveLeft
        dex
        dec P0FrameCounter
SkipMoveLeft
	lda #%10000000	;Right?
	bit SWCHA 
	bne SkipMoveRight
        cpx #CONS_BOUNDRY_P0_RIGHT
        bcs SkipMoveRight
        inx
        dec P0FrameCounter
SkipMoveRight
	stx P0XPos
        lda P0FrameCounter
        cmp #0
        bpl joystickEnd
        ;TODO -- can probaby handle this faster!
        FLIP_BOOL P0FrameIdx
        cmp #$01
        beq DrawFrameB
DrawFrameA
        lda #<P0_Frame_0
        sta P0Ptr
        lda #>P0_Frame_0
        sta P0Ptr+1
        jmp ResetFrameTimer
DrawFrameB
        lda #<P0_Frame_1
        sta P0Ptr
        lda #>P0_Frame_1
        sta P0Ptr+1
ResetFrameTimer
        lda #CONS_FRAME_ANIMATION_COUNTER
        sta P0FrameCounter
joystickEnd
	rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;
PF_Kernal_Tower
        .byte #%11110000
        .byte #%11110111
        .byte #%01111111  
   
        .byte #%11110000
        .byte #%11110111
        .byte #%01111111    

        .byte #%11110000
        .byte #%11110111
        .byte #%01111111 
;----------------------------
        .byte #%11110000
        .byte #%11100011
        .byte #%01111111  
   
        .byte #%11110000
        .byte #%11100011
        .byte #%01111111    

        .byte #%11110000
        .byte #%11100011
        .byte #%01111111 
;----------------------------
        .byte #%11110000
        .byte #%11000001
        .byte #%01111111  
   
        .byte #%11110000
        .byte #%11000001
        .byte #%01111111    

        .byte #%11110000
        .byte #%11000001
        .byte #%01111111 
;----------------------------
        .byte #%11110000
        .byte #%10000000
        .byte #%01111111

        .byte #%11110000
        .byte #%10000000
        .byte #%01111111

        .byte #%11110000
        .byte #%10000000
        .byte #%01111111
;----------------------------
        .byte #0
P0_Frame_0
        ; draw from top to bottom
        .byte #%01111100
        .byte #%01111110
        .byte #%01101000
        .byte #%01111100
        .byte #%00111100
        .byte #%00000000
        .byte #%01111000
        .byte #%10111101
        .byte #%10111110
        .byte #%01011100
        .byte #%01111000
        .byte #%00000000
        .byte #%01110110
        .byte #0
P0_Frame_1
        ; draw from top to bottom
        .byte #%01111100
        .byte #%01111110
        .byte #%01101000
        .byte #%01111100
        .byte #%00111100
        .byte #%00000000
        .byte #%01111000
        .byte #%10111101
        .byte #%10111110
        .byte #%01011100
        .byte #%01111000
        .byte #%00000000
        .byte #%00111100
        .byte #0
P1_Frame_0
        ; draw from top to bottom
        .byte #%00111110   ; 0x3E
        .byte #%01111110   ; 0x7E
        .byte #%00010110   ; 0x16
        .byte #%00111110   ; 0x3E
        .byte #%00111100   ; 0x3C
        .byte #%00000000   ; 0x00
        .byte #%00011110   ; 0x1E
        .byte #%10111101   ; 0xBD
        .byte #%01111101   ; 0x7D
        .byte #%00111010   ; 0x3A
        .byte #%00011110   ; 0x1E
        .byte #%00000000   ; 0x00
        .byte #%01101110   ; 0x6E
        .byte #0 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;
        org $fffc
        .word Start ; reset vector
        .word Start ; BRK vector