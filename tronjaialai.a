
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants
CONS_PLAYER_HEIGHT  EQU  $0E ; FF-intended height
CONS_TOWER_HEIGHT   EQU  $30
CONS_TILE_HEIGHT    EQU  #15
CONS_TILE_HIDE      EQU  %00000000

CONS_COLOR_BLACK EQU $00
CONS_COLOR_RED   EQU $40
CONS_COLOR_PINK  EQU $4A
CONS_COLOR_BLUE  EQU $82
CONS_COLOR_TEAL  EQU $8D
CONS_COLOR_GREEN EQU $C6
CONS_COLOR_CHART EQU $CA

CONS_FRAME_ANIMATION_COUNTER EQU $03

CONS_P0_STARTING_JOYSTICK_BYTE EQU %10000000
CONS_P1_STARTING_JOYSTICK_BYTE EQU %00001000
CONS_BOUNDRY_P0_LEFT  EQU #23
CONS_BOUNDRY_P0_RIGHT EQU #64
CONS_BOUNDRY_P1_LEFT  EQU #108
CONS_BOUNDRY_P1_RIGHT EQU #148
CONS_BOUNDRY_TOP      EQU #00
CONS_BOUNDRY_BOTTOM   EQU #29
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
; TODO add to includes
;--------
; FLIP_BOOL
; Original author: Andy Garber
; Takes a memory address and flips it's value than stores it
; Assumes the Memory address value is 1 or 0
; usage: FLIP_BOOL SomeAddress
        MAC FLIP_BOOL
.MEMADDR     SET {1}
        lda .MEMADDR
        EOR #$01
        sta .MEMADDR
        ENDM
;--------
; CLEAR_PLAYFIELD
; Original author: Andy Garber
; sets playfield to 0 across the board
; usage: CLEAR_PLAYFIELD
        MAC CLEAR_PLAYFIELD
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        ENDM
;--------
; LOAD_POINTER_WITH_DATA
; Original author: Andy Garber
; Loads a pointer with low byte than high byte address of data object
; usage: LOAD_POINTER_WITH_DATA pointer data
        MAC LOAD_POINTER_WITH_DATA
.POINTER      SET {1}
.DATA_BLOB    SET {2}
          lda #<.DATA_BLOB
          sta .POINTER
          lda #>.DATA_BLOB
          sta .POINTER+1
        ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80
boolDraw        .byte
LineIdx         .byte

loopIntI        .byte
loopIntJ        .byte

pf_Index        .byte

pf_TileData_Left   .DS 9
pf_TileData_Right  .DS 9

horizontalBoundries .DS 2

P0XPos          .byte ;-- X coordinates
P1XPos          .byte

P0YPos          .byte ;-- Y coordinate (offset from the start of the playfield)
P1YPos          .byte

P0MssleYPos     .byte
P1MssleYPos     .byte

P0Idx           .byte ;-- data index of our sprite data
P1Idx           .byte

P0FrameIdx      .byte ;--- animation frame
P0FrameCounter  .byte ;--- frame counter

P0Ptr		.DS 2
P1Ptr		.DS 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment
	seg Code
        org $f000
Start
	CLEAN_START
        ldx #$00
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
; 37 lines of underscan
	TIMER_SETUP 37
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_Movement
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; This is where we do player X logic
	sta WSYNC
        lda #30      ; get X coordinate
        ldx #0          ; player 0
        jsr SetHorizPos ; set coarse offset

        lda #140      ; get X coordinate
        ldx #1          ; player 1
        jsr SetHorizPos ; set coarse offset
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
       
        TIMER_WAIT
OnScreen
	TIMER_SETUP 195
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat_Pre
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is just a spacing between the towers and combat area. sort of a preset for the combat area?
; we setup the presets for the complex stuff below!
        
        lda #$01
        sta CTRLPF 
        lda #CONS_COLOR_BLUE
        sta COLUPF

        lda #CONS_COLOR_BLACK
        sta COLUBK
  	;------------------------- vv This is for demo purposes
        CLEAR_PLAYFIELD
        ; TODO -- obviously we set this up somewhere ELSE.
     	ldy #$00
        lda #%11110000
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        
        ldy #$01
        lda #%11111111
        sta pf_TileData_Left,y
        lda #%11101111
        sta pf_TileData_Right,y
        iny
        iny
        iny
        lda #%11101111
        sta pf_TileData_Left,y
        lda #%11111111
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        
        ldy #$02
        lda #%00111111
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        ldy #$00
        
        lda #03
        sta P0YPos
        lda #06
        sta P1YPos
        lda #CONS_PLAYER_HEIGHT
        sta P0Idx
        sta P1Idx
        
        ;lda #<P0_Frame_1
        ;sta P0Ptr
        ;lda #>P0_Frame_1
        ;sta P0Ptr+1
        ;lda #<P0_Frame_1
        ;sta P1Ptr
        ;lda #>P0_Frame_1
        ;sta P1Ptr+1
        LOAD_POINTER_WITH_DATA P0Ptr,P0_Frame_1
        LOAD_POINTER_WITH_DATA P1Ptr,P0_Frame_1
        ;------------------------- ^^^ This is for demo purposes
        lda #00
        sta LineIdx
        sta pf_Index
        
        lda #3
        sta loopIntI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; -- this may have to be a 3 line ordeal!
;; line 1 draw missle and player
;; line 2 draw playfield
;; line 3 calculates indexes and stuff?
        ldx #5
Kernal_Combat_LoopX
;; --- Because of the complexities -- we will resize players, draw as 3 lines
Kernal_Combat_Objects
	jsr DrawObjects
Kernal_Combat_Draw_Playfield_Line
	sta WSYNC
        lda #CONS_COLOR_BLUE
        sta COLUPF
        ldy pf_Index ; TODO -- possible to just use the loop Int?
        ; ---- Draw Playfield Left
        lda pf_TileData_Left,y
        sta PF0
        lda pf_TileData_Left,y+1
        sta PF1
        lda pf_TileData_Left,y+2
        sta PF2
	; ---- Draw Playfield
        ;SLEEP 2 ; for asynchronus playfielding keep in case we get too drifty
        lda pf_TileData_Right,y
        sta PF0
        lda pf_TileData_Right,y+1
        sta PF1
        lda pf_TileData_Right,y+2
        sta PF2
Kernal_Combat_Draw_Calculations
	sta WSYNC
        lda #CONS_COLOR_BLACK
        sta COLUPF
        clc
        ; -- uodate Line IDX for players
	lda LineIdx
        adc #$03
        sta LineIdx
        ; -- do player calcs on sprite BEGINNING
        cmp P0YPos
        bne .skipLeftBegin
        ldy #$00
        sty P0Idx
.skipLeftBegin
        cmp P1YPos
        bne .skipRightBegin
        ldy #$00
        sty P1Idx
.skipRightBegin
	; -- do player calcs on sprite END
        lda P0Idx
        cmp #CONS_PLAYER_HEIGHT
        bpl .skipLeftEnd
        inc P0Idx
.skipLeftEnd
        lda P1Idx
        cmp #CONS_PLAYER_HEIGHT
        bpl .skipRightEnd
        inc P1Idx
.skipRightEnd
        ; -- Dec X to represent a group of 3 lines
        dex
        bne Kernal_Combat_LoopX
Kernal_Combat_Segment_Loop
	; ---- Increment the playfield segment by the time we get here.
	clc ; -- keeps the CARRY out!
        lda pf_Index ;; TODO -- if we somehow eliminate the need for pf_Index we find ourselves in a win win and saving 8 whole cycles!!!!
        adc #03
        sta pf_Index
	dec loopIntI
        bne Kernal_Combat
Kernal_Combat_End
	sta WSYNC
        ; -- Turn it all off
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        sta GRP0
        sta GRP1
        sta ENAM0
        sta ENAM1
        nop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 29 lines of overscan
	TIMER_SETUP 29
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC        ; start a new line
        sec               ; set carry flag
DivideLoop
        sbc #15          ; subtract 15
        bcs DivideLoop   ; branch until negative
        eor #7           ; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x      ; fix coarse position
        sta HMP0,x       ; set fine offset
        rts              ; return to caller
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DrawObjects
        sta WSYNC
        ; ----  turn OFF playfield
        lda #CONS_COLOR_BLACK
        sta COLUPF
        ; ---- Draw Missles -- this is for EVERY line
        lda #$01 ; if boolean for draw missle true, do it.
        cmp #$00
        beq .skipToPlayers
        lda #02
        sta ENAM0
.skipToPlayers       
        ; ---- Draw Player Left
        ldy P0Idx
        lda P0_Color,y
        sta COLUP0
        lda (P0Ptr),y
        sta GRP0

	; ---- Draw Player Right
        ldy P1Idx
        lda P0_Color,y
        sta COLUP1
        lda (P1Ptr),y
        sta GRP1
        
        rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
P0_Frame_1
        ;draw from top to bottom
        .byte #%00000000 ; pre-amble
        .byte #%01111100 ;0
        .byte #%01111110 ;1
        .byte #%01101000 ;2
        .byte #%01111100 ;3
        .byte #%00111100 ;4
        .byte #%00000000 ;5
        .byte #%01111000 ;6 
        .byte #%10111101 ;7
        .byte #%10111110 ;8
        .byte #%01011100 ;9
        .byte #%01111000 ;10
        .byte #%00000000 ;12
        .byte #%01110110 ;11
        .byte #%00000000 ;12
P0_Color
        ;draw from top to bottom
        .byte #CONS_COLOR_PINK ;0
        .byte #CONS_COLOR_PINK ;0
        .byte #CONS_COLOR_CHART ;1
        .byte #CONS_COLOR_CHART ;2
        .byte #CONS_COLOR_PINK ;3
        .byte #CONS_COLOR_PINK ;4
        .byte #CONS_COLOR_PINK ;5
        .byte #CONS_COLOR_PINK ;6 
        .byte #CONS_COLOR_PINK ;7
        .byte #CONS_COLOR_PINK ;8
        .byte #CONS_COLOR_PINK ;9
        .byte #CONS_COLOR_PINK ;10
        .byte #CONS_COLOR_PINK ;12
        .byte #CONS_COLOR_PINK ;11
        .byte #CONS_COLOR_PINK ;12
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector