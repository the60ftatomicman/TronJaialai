
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants
CONS_PLAYER_HEIGHT  EQU  $F2 ; FF-intended height
CONS_TOWER_HEIGHT   EQU  $30
CONS_TILE_HEIGHT    EQU  #15
CONS_TILE_HIDE      EQU  %00000000

CONS_COLOR_BLACK EQU $00
CONS_COLOR_RED   EQU $40
CONS_COLOR_PINK  EQU $4A
CONS_COLOR_BLUE  EQU $82
CONS_COLOR_TEAL  EQU $8D
CONS_COLOR_GREEN EQU $C6
CONS_COLOR_CHART EQU $CA

CONS_FRAME_ANIMATION_COUNTER EQU $03

CONS_P0_STARTING_JOYSTICK_BYTE EQU %10000000
CONS_P1_STARTING_JOYSTICK_BYTE EQU %00001000
CONS_BOUNDRY_P0_LEFT  EQU #23
CONS_BOUNDRY_P0_RIGHT EQU #64
CONS_BOUNDRY_P1_LEFT  EQU #108
CONS_BOUNDRY_P1_RIGHT EQU #148
CONS_BOUNDRY_TOP      EQU #00
CONS_BOUNDRY_BOTTOM   EQU #29
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
; TODO add to includes
;--------
; FLIP_BOOL duration
; Original author: Andy Garber
; Takes a memory address and flips it's value than stores it
; Assumes the Memory address value is 1 or 0
;usage: FLIP_BOOL SomeAddress
        MAC FLIP_BOOL
.MEMADDR     SET {1}
        lda .MEMADDR
        EOR #$01
        sta .MEMADDR
        ENDM
;--------
; CLEAR_PLAYFIELD duration
; Original author: Andy Garber
; sets playfield to 0 across the board
        MAC CLEAR_PLAYFIELD
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        ENDM
        
;--------
; FILL_PLAYFIELD duration
; Original author: Andy Garber
; sets playfield to 1 across the board
        MAC FILL_PLAYFIELD
        lda #%11111111
        sta PF0
        sta PF1
        sta PF2
        ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80
boolDraw        .byte
LineIdx         .byte

loopIntI        .byte
loopIntJ        .byte
loopIntK        .byte

pf_Index            .byte

pf_TileData_Left   .DS 6
pf_TileData_Right  .DS 6

player_Temp         .DS 2 ; -- this holds the current line needed for the player to draw
horizontalBoundries .DS 2

P0XPos          .byte ;-- X coordinates
P1XPos          .byte

P0YPos          .byte ;-- Y coordinate (offset from the start of the playfield)
P1YPos          .byte

P0MssleYPos     .byte
P1MssleYPos     .byte

P0Idx           .byte ;-- data index of our sprite data
P1Idx           .byte

P0CIdx          .byte ;-- color index of our sprite data
P1CIdx          .byte

P0FrameIdx      .byte ;--- animation frame
P0FrameCounter  .byte ;--- frame counter

P0Ptr		.DS 2
P1Ptr		.DS 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment
	seg Code
        org $f000
Start
	CLEAN_START
        ldx #$00
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
; 37 lines of underscan
	TIMER_SETUP 37
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_Movement
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; This is where we do player X logic
	sta WSYNC
        lda #30      ; get X coordinate
        ldx #0          ; player 0
        jsr SetHorizPos ; set coarse offset

        lda #140      ; get X coordinate
        ldx #1          ; player 1
        jsr SetHorizPos ; set coarse offset
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
       
        TIMER_WAIT
OnScreen
	TIMER_SETUP 195
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat_Pre
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is just a spacing between the towers and combat area. sort of a preset for the combat area?
; we setup the presets for the complex stuff below!
        CLEAR_PLAYFIELD
        lda #$01
        sta CTRLPF 
        lda #CONS_COLOR_BLUE
        sta COLUPF
        lda #CONS_COLOR_PINK
        sta COLUP0
        lda #CONS_COLOR_CHART
        sta COLUP1
        lda #CONS_COLOR_BLACK
        sta COLUBK
        
        ldy #6
clearPFBools
        lda #%11111111
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        dey
        bne clearPFBools
        
        lda #%11110011
        ldy #00
        sta pf_TileData_Right,y+2
        
        lda #00 ; -- this is our index diff!
        sta pf_Index
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; -- this may have to be a 3 line ordeal!
;; loop 1 draws left
;; loop 2 draws right
;; loop 3 calculates indexes
        lda $03
        ldx #22
        
Kernal_Combat_LoopI
	sta WSYNC
        lda boolDraw
        cmp $01
        bne Kernal_Combat_Draw_Playfield
Kernal_Combat_Draw_Objects
        lda #CONS_COLOR_BLACK
        sta COLUPF
        ; ---- Draw Players
        lda $01 ; if boolean for draw player true, do it.
        cmp $00
        lda #%00000000
        sta GRP0
        lda $01 ; if boolean for draw player true, do it.
        cmp $00
        lda #%00000000
        sta GRP1  
        
        ; ---- Draw Missles
        lda #02
        sta ENAM0
        sta ENAM1

        ; -- do logic if we ought to DRAW the player here
        jmp Kernal_Combat_Draw_Loop
        
Kernal_Combat_Draw_Playfield        
        lda #CONS_COLOR_BLUE
        sta COLUPF
        ldy pf_Index
        ; ---- Draw Playfield Left
        lda pf_TileData_Left,y+1
        sta PF0
        lda pf_TileData_Left,y+2
        sta PF1
        lda pf_TileData_Left,y+3
        sta PF2
        
        ; ---- Draw Playfield Right
        ;SLEEP 11
        lda pf_TileData_Right,y+1
        sta PF0
        lda pf_TileData_Right,y+2
        sta PF1
        lda pf_TileData_Right,y+3
        sta PF2
        
	;---------------------- test if new segment, update pf_Index
        ;inc loopIntJ
       	;tay
        ;adc #03
        ;sta pf_Index
	;---------------------- End Loop I
Kernal_Combat_Draw_Loop
	FLIP_BOOL boolDraw ; HAVE to flip the line setter HERE
	dex
        bne Kernal_Combat_LoopI
Kernal_Combat_End
	sta WSYNC
	CLEAR_PLAYFIELD
        lda #CONS_COLOR_BLACK
        sta COLUP0
        lda #CONS_COLOR_BLACK
        sta COLUP1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 29 lines of overscan
	TIMER_SETUP 29
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC        ; start a new line
        sec               ; set carry flag
DivideLoop
        sbc #15          ; subtract 15
        bcs DivideLoop   ; branch until negative
        eor #7           ; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x      ; fix coarse position
        sta HMP0,x       ; set fine offset
        rts              ; return to caller
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector