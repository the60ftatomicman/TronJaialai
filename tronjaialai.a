
	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants
CONS_PLAYER_HEIGHT  EQU  $F2 ; FF-intended height
CONS_TOWER_HEIGHT   EQU  $30
CONS_TILE_HEIGHT    EQU  #15
CONS_TILE_HIDE      EQU  %00000000

CONS_COLOR_BLACK EQU $00
CONS_COLOR_RED   EQU $40
CONS_COLOR_PINK  EQU $4A
CONS_COLOR_BLUE  EQU $82
CONS_COLOR_TEAL  EQU $8D
CONS_COLOR_GREEN EQU $C6
CONS_COLOR_CHART EQU $CA

CONS_FRAME_ANIMATION_COUNTER EQU $03

CONS_P0_STARTING_JOYSTICK_BYTE EQU %10000000
CONS_P1_STARTING_JOYSTICK_BYTE EQU %00001000
CONS_BOUNDRY_P0_LEFT  EQU #23
CONS_BOUNDRY_P0_RIGHT EQU #64
CONS_BOUNDRY_P1_LEFT  EQU #108
CONS_BOUNDRY_P1_RIGHT EQU #148
CONS_BOUNDRY_TOP      EQU #00
CONS_BOUNDRY_BOTTOM   EQU #29
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
; TODO add to includes
;--------
; FLIP_BOOL duration
; Original author: Andy Garber
; Takes a memory address and flips it's value than stores it
; Assumes the Memory address value is 1 or 0
;usage: FLIP_BOOL SomeAddress
        MAC FLIP_BOOL
.MEMADDR     SET {1}
        lda .MEMADDR
        EOR #$01
        sta .MEMADDR
        ENDM
;--------
; CLEAR_PLAYFIELD duration
; Original author: Andy Garber
; sets playfield to 0 across the board
        MAC CLEAR_PLAYFIELD
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        ENDM
        
;--------
; FILL_PLAYFIELD duration
; Original author: Andy Garber
; sets playfield to 1 across the board
        MAC FILL_PLAYFIELD
        lda #%11111111
        sta PF0
        sta PF1
        sta PF2
        ENDM
;--------
; DRAW_MISSLE 
; Original author: Andy Garber
; Draws a missle based on a byte containing it's Y axis.
        MAC DRAW_MISSLE
.YPOS        SET {1}
.MISSLE_REG  SET {2}
        lda .YPOS
        SBC LineIdx ; TODO --- this is going to have be be at EVERY location.....
        BNE .skip
        lda #%0000010
        jmp .end
.skip
        lda #%0000000
.end   
        sta .MISSLE_REG
        ENDM        
;--------
; DRAW_PLAYER duration
; Original author: Andy Garber
; Draws a player based on the lineIdx var
        MAC DRAW_PLAYER
.YPOS        SET {1}
.HEIGHT      SET {2}
.PLAYER_REG  SET {3}
.PLAYER_PTR  SET {4}
.PLAYER_IDX  SET {5}
	ldy .PLAYER_IDX
        lda .YPOS
        SBC LineIdx
        BPL .skip
        CMP #.HEIGHT
        BMI .skip
        lda (.PLAYER_PTR),y
        inc .PLAYER_IDX
        jmp .end
.skip
        lda #%0000000
.end   
        sta .PLAYER_REG
        ENDM
;--------
; MOVE_PLAYER duration
; Original author: Andy Garber
; Moves the player
        MAC MOVE_PLAYER
.PLAYEROFFSET      SET {1}
.LEFT_BOUNDRY      SET {2}
.RIGHT_BOUNDRY     SET {3}
.STARTING_JOYSTICK SET {4}
        ldx $01
        lda #.RIGHT_BOUNDRY
        sta horizontalBoundries
        lda #.LEFT_BOUNDRY
        sta horizontalBoundries,x
        lda #.STARTING_JOYSTICK
        ldy #.PLAYEROFFSET
	jsr MoveJoystick
        ENDM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables segment

        seg.u Variables
	org $80
boolDraw        .byte
LineIdx         .byte

loopIntI        .byte
loopIntJ        .byte
loopIntK        .byte

pf_Index            .byte
p0_TileBooleans     .DS 9
p1_TileBooleans     .DS 9
pf_Temp             .DS 6
horizontalBoundries .DS 2

P0XPos          .byte ;-- X coordinates
P1XPos          .byte

P0YPos          .byte ;-- Y coordinate (offset from the start of the playfield)
P1YPos          .byte

P0MssleYPos     .byte
P1MssleYPos     .byte

P0Idx           .byte ;-- data index of our sprite data
P1Idx           .byte

P0CIdx          .byte ;-- color index of our sprite data
P1CIdx          .byte

P0FrameIdx      .byte ;--- animation frame
P0FrameCounter  .byte ;--- frame counter

P0Ptr		.DS 2
P1Ptr		.DS 2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code segment
	seg Code
        org $f000
Start
	CLEAN_START
        ldx #$00
init_PF_Tiles
; Loop commented out but lets make it debuggable
          lda #%11110000
          sta p0_TileBooleans,x
          lda #%10010000
          sta p1_TileBooleans,x
          lda #%11111011
          sta p0_TileBooleans,x+1
          lda #%11111011
          sta p1_TileBooleans,x+1    
          lda #%01111111
          sta p0_TileBooleans,x+2
          lda #%01111111
          sta p1_TileBooleans,x+2 

          lda #%11110000
          sta p0_TileBooleans,x+3
          sta p1_TileBooleans,x+3
          lda #%11111011
          sta p0_TileBooleans,x+4
          sta p1_TileBooleans,x+4    
          lda #%01111111
          sta p0_TileBooleans,x+5
          sta p1_TileBooleans,x+5 

          lda #%11110000
          sta p0_TileBooleans,x+6
          sta p1_TileBooleans,x+6
          lda #%11111011
          sta p0_TileBooleans,x+7
          sta p1_TileBooleans,x+7    
          lda #%01111111
          sta p0_TileBooleans,x+8
          sta p1_TileBooleans,x+8 

;        inx
;        inx
;        inx
;        txa
;        cmp $09
;        bne init_PF_Tiles
        
init_Players        
        lda #CONS_BOUNDRY_P0_LEFT+1  ; Max Left
        sta P0XPos
        lda #CONS_BOUNDRY_P1_RIGHT-1 ; Max right
        sta P1XPos
        lda #CONS_BOUNDRY_TOP+3
        sta P0YPos
        sta P1YPos
        sta P0MssleYPos
        sta P1MssleYPos

        lda #0
        sta P0Idx
        sta P1Idx
        lda #CONS_FRAME_ANIMATION_COUNTER
        sta P0FrameCounter

        lda #<P0_Frame_0
        sta P0Ptr
        lda #>P0_Frame_0
        sta P0Ptr+1
        
        lda #<P1_Frame_0
        sta P1Ptr
        lda #>P0_Frame_0
        sta P1Ptr+1
        
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
; 37 lines of underscan
	TIMER_SETUP 37
          lda #$01
          sta CTRLPF 
          CLEAR_PLAYFIELD
          lda #CONS_COLOR_PINK
          sta COLUP0
          lda #CONS_COLOR_CHART
          sta COLUP1
          lda #CONS_COLOR_BLACK
          sta COLUBK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_Movement
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; This is where we do player X logic
	sta WSYNC
        lda P0XPos      ; get X coordinate
        ldx #0          ; player 0
        jsr SetHorizPos ; set coarse offset

        lda P1XPos      ; get X coordinate
        ldx #1          ; player 1
        jsr SetHorizPos ; set coarse offset
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
       
        TIMER_WAIT
OnScreen
	TIMER_SETUP 195
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;         
Kernal_Tower
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; Background art for the upper half of the game.
; PF is set to Mirror and we just draw. than wait
; The BLACK we see is really the PF mirroed.
; Color of the towers is controlled by the background.
; TODO make this less gross.
        ; Now setup the next parts
        lda #CONS_COLOR_BLACK
        sta COLUPF
        lda #%11110000
        sta PF0  
        lda #%01111111 
        sta PF2

        ldx #$0
        ldy #CONS_TOWER_HEIGHT+40 ; this integer controls gap at TOP of the arrow
        
Kernal_Tower_Draw
	sta WSYNC
        tya
        cmp #CONS_TOWER_HEIGHT
        bmi Kernal_Tower_Draw_All3Columns
        cmp #CONS_TOWER_HEIGHT+9  ; 9 represents the number of data lines in our Arrow head
        bmi Kernal_Tower_Draw_ArrowTop
Kernal_Tower_Draw_MidOnly
        lda #%11111111
        sta PF1
        jmp Kernal_Tower_Draw_Colorize
Kernal_Tower_Draw_ArrowTop
        lda PF_Kernal_Tower,x 
        sta PF1
        inx
        jmp Kernal_Tower_Draw_Colorize
Kernal_Tower_Draw_All3Columns
        lda #%11110111
        sta PF1
        jmp Kernal_Tower_Draw_Colorize
Kernal_Tower_Draw_Colorize   
        lda #CONS_COLOR_RED
        sta COLUBK
        SLEEP 15
        lda #CONS_COLOR_TEAL
        sta COLUBK      
        SLEEP 8 
        lda #CONS_COLOR_GREEN
        sta COLUBK
        dey
        bne Kernal_Tower_Draw
Kernal_Tower_End
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Stairs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This draws a nice staircase from our tower
; More background mumbo jumbo
        lda #CONS_COLOR_BLACK
        sta COLUBK
	CLEAR_PLAYFIELD
        lda #CONS_COLOR_BLUE
        sta COLUPF
        ldx #2 ; this will always do +1 what you want
        stx loopIntI
        lda #%11110000
Kernal_Stairs_I
        ldx #3 ; this will always do +1 what you want
        stx loopIntJ
Kernal_Stairs_J
        sta WSYNC
        sta PF2
        DEC loopIntJ
        BPL Kernal_Stairs_J
        LSR
        LSR
        DEC loopIntI
        BPL Kernal_Stairs_I
Kernal_Stairs_end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Gap
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is just a spacing between the towers and combat area. sort of a preset for the combat area?
; we setup the presets for the complex stuff below!
        CLEAR_PLAYFIELD
        lda #CONS_COLOR_BLUE
        sta COLUPF
       
        lda #3 
        sta loopIntI
        lda #0 ; uused to change address levels
        sta pf_Index
        sta LineIdx
        sta WSYNC
Kernal_Gap_end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat_LoopI
	;Sets playfield flagst to memory locations for faster load
        jsr SetPlayfieldForCombatSection
        lda #25 ; was 25 
        sta loopIntJ
Kernal_Combat_LoopJ
	FLIP_BOOL boolDraw
        BEQ Kernal_Combat_LoopJ_Players
Kernal_Combat_LoopJ_Playfield
	sta WSYNC
        ;Draw Playfield
        lda pf_Temp
        sta PF0
        lda pf_Temp+1
        sta PF1
        lda pf_Temp+2
        sta PF2
        SLEEP 7; was working at 7
        lda pf_Temp+3
        sta PF0
        lda pf_Temp+4
        sta PF1
        lda pf_Temp+5
        sta PF2
        SLEEP 27
        CLEAR_PLAYFIELD
        jmp Kernal_Combat_LoopJ_Inc
Kernal_Combat_LoopJ_Players
        ;Draw Players
        ;DRAW_PLAYER P0YPos, CONS_PLAYER_HEIGHT, GRP0, P0Ptr,P0Idx
Kernal_Combat_LoopJ_Inc
       	adc LineIdx
        dec loopIntJ
        bne Kernal_Combat_LoopJ
Kernal_Combat_LoopJ_END
	CLEAR_PLAYFIELD
        sta WSYNC
        
        ;Update pf_Index
        lda pf_Index
        adc #3
        sta pf_Index
        
	dec loopIntI
        bne Kernal_Combat_LoopI
Kernal_Combat_End
	CLEAR_PLAYFIELD
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Overscan
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 29 lines of overscan
	TIMER_SETUP 29
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SetPlayfieldForCombatSection
	ldy pf_Index
        lda p0_TileBooleans,y
        sta pf_Temp
        lda p0_TileBooleans,y+1
        sta pf_Temp+1
        lda p0_TileBooleans,y+2
        sta pf_Temp+2
        lda p1_TileBooleans,y
        sta pf_Temp+3
        lda p1_TileBooleans,y+1
        sta pf_Temp+4
        lda p1_TileBooleans,y+2
        sta pf_Temp+5
        rts
DrawPlayfieldForCombatSection

        rts
; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC        ; start a new line
        sec               ; set carry flag
DivideLoop
        sbc #15          ; subtract 15
        bcs DivideLoop   ; branch until negative
        eor #7           ; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x      ; fix coarse position
        sta HMP0,x       ; set fine offset
        rts              ; return to caller
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PF_Kernal_Tower
        .byte #%11110111
        .byte #%11110111
        .byte #%11110111
;----------------------------
        .byte #%11100011
        .byte #%11100011
        .byte #%11100011
;----------------------------
        .byte #%11000001
        .byte #%11000001  
        .byte #%11000001
;----------------------------
        .byte #%10000000
        .byte #%10000000
        .byte #%10000000
;----------------------------
        .byte #0
P0_Frame_0
        ; draw from top to bottom
        .byte #%01111100
        .byte #%01111110
        .byte #%01101000
        .byte #%01111100
        .byte #%00111100
        .byte #%00000000
        .byte #%01111000
        .byte #%10111101
        .byte #%10111110
        .byte #%01011100
        .byte #%01111000
        .byte #%00000000
        .byte #%01110110
        .byte #0
P0_Frame_1
        ; draw from top to bottom
        .byte #%01111100
        .byte #%01111110
        .byte #%01101000
        .byte #%01111100
        .byte #%00111100
        .byte #%00000000
        .byte #%01111000
        .byte #%10111101
        .byte #%10111110
        .byte #%01011100
        .byte #%01111000
        .byte #%00000000
        .byte #%00111100
        .byte #0
P1_Frame_0
        ; draw from top to bottom
        .byte #%00111110   ; 0x3E
        .byte #%01111110   ; 0x7E
        .byte #%00010110   ; 0x16
        .byte #%00111110   ; 0x3E
        .byte #%00111100   ; 0x3C
        .byte #%00000000   ; 0x00
        .byte #%00011110   ; 0x1E
        .byte #%10111101   ; 0xBD
        .byte #%01111101   ; 0x7D
        .byte #%00111010   ; 0x3A
        .byte #%00011110   ; 0x1E
        .byte #%00000000   ; 0x00
        .byte #%01101110   ; 0x6E
        .byte #0 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
