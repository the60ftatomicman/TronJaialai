	processor 6502
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Constants
        include "constants.inc"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Macros
        include "usermacro.inc"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Variables 
        seg.u Variables
	org $80
	include "variables.inc"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Code
	seg Code
        org $f000
Start
	CLEAN_START
        ldx #$00
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;;--- Initalize a few super static things
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	lda #$01
	sta boolSetupRound
        lda #$08
        sta REFP1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;;--- Initalize a few
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
NextFrame
        lsr SWCHB	; test Game Reset switch
        bcc Start	; reset?
; 1 + 3 lines of VSYNC
	VERTICAL_SYNC
; 37 lines of underscan
	TIMER_SETUP 37
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_RoundSetup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
	lda boolSetupRound
        cmp #$00
        beq Kernal_Movement
        lda #30
        sta P0XPos
        lda #140
        sta P1XPos
        lda #$00
        sta boolSetupRound
        lda #03
        sta P0YPos
        sta P1YPos
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
Kernal_Movement
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
; This is where we do player X logic
	sta WSYNC
        ; -- set LEFT player X
        lda P0XPos         ; get X coordinate
        ldx #0          ; player 0 (LEFT)
        jsr SetHorizPos ; set coarse offset
        ; -- set Right player X
        lda P1XPos      ; get X coordinate
        ldx #1          ; player 1 (RIGHT)
        jsr SetHorizPos ; set coarse offset
        
        sta WSYNC       ; sync w/ scanline
        sta HMOVE       ; apply fine offsets
       
        TIMER_WAIT
OnScreen
	TIMER_SETUP 195
        
        
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
        ldx #$10
Kernal_Test_Delay_1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
        dex
        bne Kernal_Test_Delay_1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ldx #$3
        lda #%11111111
        sta PF0
        sta PF1
        sta PF2
        lda #02
        sta ENAM1
Kernal_Ceiling
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        sta WSYNC
        lda #CONS_COLOR_BLUE
        sta COLUPF
        dex
        bne Kernal_Ceiling
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
        lda #00
        sta ENAM1
        lda #CONS_COLOR_BLACK
        sta COLUPF
        ldx #$40
Kernal_Test_Delay_2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
        dex
        bne Kernal_Test_Delay_2
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat_Pre
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; This is just a spacing between the towers and combat area. sort of a preset for the combat area?
; we setup the presets for the complex stuff below!
        lda #$01
        sta CTRLPF 
        lda #CONS_COLOR_BLUE
        sta COLUPF

        lda #CONS_COLOR_BLACK
        sta COLUBK
        ;------------------------- vv This is for demo purposes
        CLEAR_PLAYFIELD
        ; TODO -- obviously we set this up somewhere ELSE.
        ldy #$00
        lda #%11110000
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        
        ldy #$01
        lda #%11111111
        sta pf_TileData_Left,y
        lda #%11101111
        sta pf_TileData_Right,y
        iny
        iny
        iny
        lda #%11101111
        sta pf_TileData_Left,y
        lda #%11111111
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        
        ldy #$02
        lda #%00111111
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        iny
        iny
        iny
        sta pf_TileData_Left,y
        sta pf_TileData_Right,y
        ldy #$00
        
        lda #CONS_PLAYER_HEIGHT
        sta P0Idx
        sta P1Idx
        
        LOAD_POINTER_WITH_DATA P0Ptr,P0_Frame_1
        LOAD_POINTER_WITH_DATA P1Ptr,P0_Frame_1
        ;------------------------- ^^^ This is for demo purposes
	lda #00
        sta LineIdx
	ldx #12
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat_JustObjects
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	sta WSYNC
        jsr CalculateObjects
        jsr DrawObjects
	dex
        bne Kernal_Combat_JustObjects
        
        
        lda #00
        sta pf_Index
        lda #3
        sta loopIntI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Kernal_Combat
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; -- this may have to be a 3 line ordeal!
;; line 1 draw missle and player
;; line 2 draw playfield
;; line 3 calculates indexes and stuff?
        ldx #5
Kernal_Combat_LoopX
;; --- Because of the complexities -- we will draw as 3 lines
Kernal_Combat_Objects
	jsr DrawObjects
Kernal_Combat_Draw_Playfield_Line
	sta WSYNC
        
        lda #CONS_COLOR_BLUE
        sta COLUPF

        ldy pf_Index ; TODO -- possible to just use the loop Int?
        ; ---- Draw Playfield Left
        lda pf_TileData_Left,y
        sta PF0
        lda pf_TileData_Left,y+1
        sta PF1
        lda pf_TileData_Left,y+2
        sta PF2
	; ---- Draw Playfield
        ;SLEEP 2 ; for asynchronus playfielding keep in case we get too drifty
        lda pf_TileData_Right,y
        sta PF0
        lda pf_TileData_Right,y+1
        sta PF1
        lda pf_TileData_Right,y+2
        sta PF2
Kernal_Combat_Draw_Calculations
	jsr CalculateObjects ; may have to bring this back sadly
        ; -- Dec X to represent a group of 3 lines
        dex
        bne Kernal_Combat_LoopX
Kernal_Combat_Segment_Loop
	; ---- Increment the playfield segment by the time we get here.
	clc ; -- keeps the CARRY out!
        lda pf_Index ;; TODO -- if we somehow eliminate the need for pf_Index we find ourselves in a win win and saving 8 whole cycles!!!!
        adc #03
        sta pf_Index
	dec loopIntI
        bne Kernal_Combat
Kernal_Combat_End
	sta WSYNC
        ; -- Turn it all off
        lda #%00000000
        sta PF0
        sta PF1
        sta PF2
        sta GRP0
        sta GRP1
        sta ENAM0
        sta ENAM1
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Input
        MOVE_PLAYER $0,CONS_BOUNDRY_P0_LEFT,CONS_BOUNDRY_P0_RIGHT,CONS_P0_STARTING_JOYSTICK_BYTE
        MOVE_PLAYER $1,CONS_BOUNDRY_P1_LEFT,CONS_BOUNDRY_P1_RIGHT,CONS_P1_STARTING_JOYSTICK_BYTE
        nop
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OffScreen
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	TIMER_WAIT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Overscan

; 29 lines of overscan
	TIMER_SETUP 29
        TIMER_WAIT
; total = 262 lines, go to next frame
        jmp NextFrame

; SetHorizPos routine
; A = X coordinate
; X = player number (0 or 1)
SetHorizPos
        sta WSYNC        ; start a new line
        sec               ; set carry flag
DivideLoop
        sbc #15          ; subtract 15
        bcs DivideLoop   ; branch until negative
        eor #7           ; calculate fine offset
        asl
        asl
        asl
        asl
        sta RESP0,x      ; fix coarse position
        sta HMP0,x       ; set fine offset
        rts              ; return to caller
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Subroutines
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DrawObjects
        sta WSYNC
        ; ----  turn OFF playfield
        lda #CONS_COLOR_BLACK
        sta COLUPF
        ; ---- Draw Missles -- this is for EVERY line
        lda #$01 ; if boolean for draw missle true, do it.
        cmp #$00
        beq .skipToPlayers
        lda #02
        sta ENAM0
.skipToPlayers       
        ; ---- Draw Player Left
        ldy P0Idx
        lda P0_Color,y
        sta COLUP0
        lda (P0Ptr),y
        sta GRP0

	; ---- Draw Player Right
        ldy P1Idx
        lda P0_Color,y
        sta COLUP1
        lda (P1Ptr),y
        sta GRP1
        rts
        
CalculateObjects
	sta WSYNC
        lda #CONS_COLOR_BLACK
        sta COLUPF
        clc
        ; -- update Line IDX for players
	lda LineIdx
        adc #$03
        sta LineIdx
        ; -- do player calcs on sprite BEGINNING
        cmp P0YPos
        bne .skipLeftBegin
        ldy #$00
        sty P0Idx
.skipLeftBegin
        cmp P1YPos
        bne .skipRightBegin
        ldy #$00
        sty P1Idx
.skipRightBegin
	; -- do player calcs on sprite END
        lda P0Idx
        cmp #CONS_PLAYER_HEIGHT
        bpl .skipLeftEnd
        inc P0Idx
.skipLeftEnd
        lda P1Idx
        cmp #CONS_PLAYER_HEIGHT
        bpl .skipRightEnd
        inc P1Idx
.skipRightEnd
	rts
;;;;;;;;;;;;;;;;;;;;;
; #%10000000 -- P1 Right
; #%01000000 -- P1 left
; #%00100000 -- P1 down
; #%00010000 -- P1 up
; #%00001000 -- P0 Right
; #%00000100 -- P0 left
; #%00000010 -- P0 down
; #%00000001 -- P0 up
; Y gives us our offsets
; A is our initial starting controller
MoveJoystick
; ----- Start Horizontal
        ldx P0XPos,y
	bit SWCHA
	bne SkipMoveRight
        cpx horizontalBoundries
        bcs SkipMoveRight
        inx
        dec P0FrameCounter
SkipMoveRight
	LSR ;---- read LEFT
	bit SWCHA 
	bne SkipMoveLeft
        cpx horizontalBoundries+1
        bcc SkipMoveLeft
        dex
        dec P0FrameCounter
SkipMoveLeft
	stx P0XPos,y
; ----- Now Vertical
        ldx P0YPos,y
        LSR ;--- read Down
        bit SWCHA
	bne SkipMoveDown
        cpx #CONS_BOUNDRY_BOTTOM
        bpl SkipMoveDown
        inx ;-- need to move the exact amount of lines otherwise we get ghosting!
        inx
        inx
        dec P0FrameCounter
SkipMoveDown
        LSR ;--- read UP
	bit SWCHA
	bne SkipMoveUp
        cpx #CONS_BOUNDRY_TOP
        bmi SkipMoveUp
        dex ;-- need to move the exact amount of lines otherwise we get ghosting!
        dex
        dex
        dec P0FrameCounter
SkipMoveUp
        stx P0YPos,y
        rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
       include "sprites.inc"
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Epilogue
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	org $fffc
        .word Start	; reset vector
        .word Start	; BRK vector
