------- FILE puzzlebubble.a LEVEL 1 PASS 2
      1  fffe					      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE puzzlebubble.a
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????						;-------------------------------------------------------
    163  0000 ????						; SKIP_SCANLINES #lines
    164  0000 ????						;
    165  0000 ????						; Skip a given # of scanlines.
    166  0000 ????						; Sets the X register to zero.
    167  0000 ????
    168  0000 ????				      MAC	skip_scanlines
    169  0000 ????			   .LINES     SET	{1}
    170  0000 ????				      ldx	#.LINES
    171  0000 ????			   .vblank    sta	WSYNC
    172  0000 ????				      dex
    173  0000 ????				      bne	.vblank
    174  0000 ????				      ENDM
    175  0000 ????
    176  0000 ????						; EOF
------- FILE puzzlebubble.a
------- FILE xmacro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"xmacro.h"
      1  0000 ????
      2  0000 ????						;-------------------------------------------------------
      3  0000 ????						; Usage: TIMER_SETUP lines
      4  0000 ????						; where lines is the number of scanlines to skip (> 2).
      5  0000 ????						; The timer will be set so that it expires before this number
      6  0000 ????						; of scanlines. A WSYNC will be done first.
      7  0000 ????
      8  0000 ????				      MAC	timer_setup
      9  0000 ????			   .lines     SET	{1}
     10  0000 ????			   .cycles    SET	((.lines * 76) - 13)
     11  0000 ????						; special case for when we have two timer events in a line
     12  0000 ????						; and our 2nd event straddles the WSYNC boundary
     13  0000 ????				      if	(.cycles % 64) < 12
     14  0000 ????				      lda	#(.cycles / 64) - 1
     15  0000 ????				      sta	WSYNC
     16  0000 ????				      else
     17  0000 ????				      lda	#(.cycles / 64)
     18  0000 ????				      sta	WSYNC
     19  0000 ????				      endif
     20  0000 ????				      sta	TIM64T
     21  0000 ????				      ENDM
     22  0000 ????
     23  0000 ????						;-------------------------------------------------------
     24  0000 ????						; Use with TIMER_SETUP to wait for timer to complete.
     25  0000 ????						; Performs a WSYNC afterwards.
     26  0000 ????
     27  0000 ????				      MAC	timer_wait
     28  0000 ????			   .waittimer
     29  0000 ????				      lda	INTIM
     30  0000 ????				      bne	.waittimer
     31  0000 ????				      sta	WSYNC
     32  0000 ????				      ENDM
------- FILE puzzlebubble.a
      5  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      6  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      7  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      8  0000 ????						; Generic Constants
      9  0000 ????
     10  0000 ????						; ---- COLORS
     11  0000 ????	       00 00	   CONS_COLOR_BLACK EQU	$00
     12  0000 ????	       00 46	   CONS_COLOR_RED EQU	$46
     13  0000 ????	       00 38	   CONS_COLOR_ORANGE EQU	$38
     14  0000 ????	       00 1e	   CONS_COLOR_YELLOW EQU	$1E
     15  0000 ????	       00 c6	   CONS_COLOR_GREEN EQU	$C6
     16  0000 ????	       00 a6	   CONS_COLOR_BLUE EQU	$A6
     17  0000 ????	       00 64	   CONS_COLOR_PURPLE EQU	$64
     18  0000 ????
     19  0000 ????	       00 3c	   CONS_COLOR_PINK EQU	$3C
     20  0000 ????	       00 8d	   CONS_COLOR_TEAL EQU	$8D
     21  0000 ????	       00 ca	   CONS_COLOR_CHART EQU	$CA
     22  0000 ????	       00 e1	   CONS_COLOR_GREY EQU	$E1
     23  0000 ????	       00 ef	   CONS_COLOR_WHITE EQU	$EF
     24  0000 ????						; ---- COLORS in Relation to OBJECTS
     25  0000 ????	       00 00	   CONS_COLOR_BLOCK_BACKGROUND EQU	#CONS_COLOR_BLACK
     26  0000 ????	       00 8d	   CONS_COLOR_LAUNCHER_BASE EQU	#CONS_COLOR_TEAL
     27  0000 ????	       00 8d	   CONS_COLOR_BORDERS EQU	#CONS_COLOR_TEAL
     28  0000 ????
     29  0000 ????						; ---- Joystick stuff
     30  0000 ????	       00 80	   CONS_P0_STARTING_JOYSTICK_BYTE EQU	%10000000
     31  0000 ????	       00 08	   CONS_P1_STARTING_JOYSTICK_BYTE EQU	%00001000
     32  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     33  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     34  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     35  0000 ????						; Macros
     36  0000 ????						;--------
     37  0000 ????						; FLIP_BOOL
     38  0000 ????						; Original author: Andy Garber
     39  0000 ????						; Takes a memory address and flips it's value than stores it
     40  0000 ????						; Assumes the Memory address value is 1 or 0
     41  0000 ????						; usage: FLIP_BOOL SomeAddress
     42  0000 ????				      MAC	flip_bool
     43  0000 ????			   .MEMADDR   SET	{1}
     44  0000 ????				      lda	.MEMADDR
     45  0000 ????				      EOR	#$01
     46  0000 ????				      sta	.MEMADDR
     47  0000 ????				      ENDM
     48  0000 ????						;--------
     49  0000 ????						; LOAD_POINTER_WITH_DATA
     50  0000 ????						; Original author: Andy Garber
     51  0000 ????						; Loads a pointer with low byte than high byte address of data object
     52  0000 ????						; usage: LOAD_POINTER_WITH_DATA pointer data
     53  0000 ????				      MAC	load_pointer_with_data
     54  0000 ????			   .POINTER   SET	{1}
     55  0000 ????			   .DATA_BLOB SET	{2}
     56  0000 ????				      lda	#<.DATA_BLOB
     57  0000 ????				      sta	.POINTER
     58  0000 ????				      lda	#>.DATA_BLOB
     59  0000 ????				      sta	.POINTER+1
     60  0000 ????				      ENDM
     61  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     62  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     63  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     64  0000 ????						; Variables segment
     65  0000 ????
     66 U00e0 ????				      seg.u	Variables
     67 U0080					      org	$80
     68 U0080
     69 U0080							; ---- Generic        
     70 U0080		       00	   boolBase   .byte.b
     71 U0081		       00	   LineIdx    .byte.b
     72 U0082		       00	   RowIdx     .byte.b
     73 U0083		       00 00	   PF_Ptr     .DS	2
     74 U0085
     75 U0085							; ---- Playfield
     76 U0085		       00 26	   CONS_LEFT_WALL EQU	#$26
     77 U0085		       00 7b	   CONS_RIGHT_WALL EQU	#$7B
     78 U0085		       00 00	   CONS_TOP_WALL EQU	#00
     79 U0085		       00 0a	   CONS_TILE_HEIGHT EQU	#10
     80 U0085		       00 11	   CONS_TILE_WIDTH EQU	#17	; ONLY for collision
     81 U0085		       00 0b	   CONS_TILE_ROWS EQU	#11
     82 U0085		       00 05	   CONS_TILE_COLS EQU	#5
     83 U0085		       00 37	   CONS_TILE_MAX EQU	#CONS_TILE_ROWS * #CONS_TILE_COLS
     84 U0085							;org $90
     85 U0085		       00 00 00 00*PF_BallStates_All .DS	#CONS_TILE_MAX
     86 U00bc		       00 00 00 00*PF_BallStates_Current .DS	#CONS_TILE_COLS+1
     87 U00c2		       00 00 00 00*PF_RowIndexes .DS	#CONS_TILE_ROWS
     88 U00cd
     89 U00cd							; ---- Player
     90 U00cd		       00 4d	   CONS_LAUNCH_START_X EQU	#CONS_LEFT_WALL+(3*13)
     91 U00cd		       00 8f	   CONS_LAUNCH_START_Y EQU	#CONS_TOP_WALL+((#CONS_TILE_HEIGHT+1)*#13)
     92 U00cd		       00 02	   CONS_PLAYER_HEIGHT EQU	#02
     93 U00cd		       00 ff	   CONS_PLAYER_WIDTH EQU	#%11111111	;#%11100000 --> 3 byte
     94 U00cd		       00 02	   CONS_PLAYER_SPEED_Y EQU	#CONS_PLAYER_HEIGHT	;2 gives me 5 steps per 10
     95 U00cd		       00 09	   CONS_PLAYER_SPEED_X EQU	#9	; 3 width 3 speed == 5 steps								 
     96 U00cd							; 6 with 6 steps == 3 steps
     97 U00cd
     98 U00cd		       00 00	   CONS_PLAYER_STATE_AIMING EQU	#$00
     99 U00cd		       00 01	   CONS_PLAYER_STATE_MOVING EQU	#$01
    100 U00cd		       00 02	   CONS_PLAYER_STATE_COLLISION_CHECK EQU	#$02
    101 U00cd		       00 03	   CONS_PLAYER_STATE_COLLISION_SET EQU	#$03
    102 U00cd							; -- X
    103 U00cd		       00 00	   PlayerXPos .DS	2
    104 U00cf		       00	   PlayerDirX .byte.b
    105 U00d0		       00 00	   Tick_PlayerX_Step .DS	2	; 0 == current, 1 == max
    106 U00d2		       00 00	   PlayerRow  .DS	2
    107 U00d4							; -- Y
    108 U00d4		       00 00	   PlayerYPos .DS	2
    109 U00d6		       00	   PlayerDirY .byte.b
    110 U00d7		       00 00	   Tick_PlayerY_Step .DS	2	; 0 == current, 1 == max 
    111 U00d9		       00 00	   PlayerCol  .DS	2
    112 U00db							; ---- Color
    113 U00db		       00 00	   PlayerColor .DS	2
    114 U00dd							; ---- State (TBD if we need this)
    115 U00dd		       00	   PlayerState .byte.b
    116 U00de
    117 U00de
    118 U00de							; -- Debug stuff, used to add 2 bytes at end to see how much we are 
    119 U00de		       00 00	   PF_TEMP    .DS	2
    120 U00e0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    121 U00e0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    122 U00e0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    123 U00e0							; Code segment
    124  10000 ????				       seg	Code
    125  f000					      org	$f000
    126  f000				   Start
      0  f000					      CLEAN_START
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002		       a2 00		      ldx	#0
      5  f004		       8a		      txa
      6  f005		       a8		      tay
      7  f006		       ca	   .CLEAR_STACK dex
      8  f007		       9a		      txs
      9  f008		       48		      pha
     10  f009		       d0 fb		      bne	.CLEAR_STACK
     11  f00b
    128  f00b							; These are so I can see where we are writing too
    129  f00b		       a9 fe		      lda	#$FE
    130  f00d		       85 de		      sta	PF_TEMP
    131  f00f		       a9 ff		      lda	#$FF
    132  f011		       85 df		      sta	PF_TEMP+1
    133  f013		       a9 8d		      lda	#CONS_COLOR_BORDERS
    134  f015		       85 07		      sta	COLUP1
    135  f017				   SetupLevel
    136  f017		       20 79 f2 	      jsr	spawnBallAtLauncher
    137  f01a							; Set level data
      0  f01a					      LOAD_POINTER_WITH_DATA	PF_Ptr,PF_Level_Colors	;; TODO this should be setup ONCE than forgotten!!
      1  f01a				   .POINTER   SET	PF_Ptr
      2  f01a				   .DATA_BLOB SET	PF_Level_Colors
      3  f01a		       a9 00		      lda	#<.DATA_BLOB
      4  f01c		       85 83		      sta	.POINTER
      5  f01e		       a9 f3		      lda	#>.DATA_BLOB
      6  f020		       85 84		      sta	.POINTER+1
    139  f022							; PF_Level_Color
    140  f022		       a0 04		      ldy	#$04
    141  f024		       a2 36		      ldx	#CONS_TILE_MAX-1
    142  f026				   loadLevelData_Colors
    143  f026		       b1 83		      lda	(PF_Ptr),y
    144  f028		       95 85		      sta	PF_BallStates_All,x
    145  f02a		       88		      dey
    146  f02b		       10 02		      bpl	.repeatColors
    147  f02d		       a0 04		      ldy	#$04
    148  f02f				   .repeatColors
    149  f02f		       ca		      dex
    150  f030		       10 f4		      bpl	loadLevelData_Colors
    151  f032							;;;	    
    152  f032							;;; Set ROW indexes for our max tiles for better writing later.
    153  f032		       a9 37		      lda	#CONS_TILE_MAX
    154  f034		       85 c2		      sta	PF_RowIndexes
    155  f036		       a4 00		      ldy	0
    156  f038		       a2 0b		      ldx	#CONS_TILE_ROWS
    157  f03a				   loadRowIndex
    158  f03a		       38		      sec
    159  f03b		       e9 05		      sbc	#CONS_TILE_COLS
    160  f03d		       99 c2 00 	      sta	PF_RowIndexes,y
    161  f040		       c8		      iny
    162  f041		       ca		      dex
    163  f042		       d0 f6		      bne	loadRowIndex
    164  f044
    165  f044		       a9 01		      lda	#CONS_PLAYER_STATE_MOVING
    166  f046		       85 dd		      sta	PlayerState
    167  f048
    168  f048				   NextFrame
    169  f048		       4e 82 02 	      lsr	SWCHB	; test Game Reset switch
    170  f04b		       90 b3		      bcc	Start	; reset?
    171  f04d							; 1 + 3 lines of VSYNC
      0  f04d					      VERTICAL_SYNC
      1  f04d		       a9 0e		      lda	#%1110
      2  f04f		       85 02	   .VSLP1     sta	WSYNC
      3  f051		       85 00		      sta	VSYNC
      4  f053		       4a		      lsr
      5  f054		       d0 f9		      bne	.VSLP1
      0  f056					      TIMER_SETUP	37
      1  f056				   .lines     SET	37
      2  f056				   .cycles    SET	((.lines * 76) - 13)
      3  f056
      4  f056
      5  f056				  -	      if	(.cycles % 64) < 12
      6  f056				  -	      lda	#(.cycles / 64) - 1
      7  f056				  -	      sta	WSYNC
      8  f056					      else
      9  f056		       a9 2b		      lda	#(.cycles / 64)
     10  f058		       85 02		      sta	WSYNC
     11  f05a					      endif
     12  f05a		       8d 96 02 	      sta	TIM64T
    174  f05d		       20 84 f1 	      jsr	setXPositionsForObjects	; Does not need to be sub routine, just like the cleanliness
    175  f060
    176  f060		       a9 00		      lda	#CONS_COLOR_BLOCK_BACKGROUND
    177  f062		       a9 01		      lda	#$01
    178  f064		       85 0a		      sta	CTRLPF
    179  f066		       a9 00		      lda	#CONS_COLOR_BLOCK_BACKGROUND
    180  f068		       85 08		      sta	COLUPF
    181  f06a		       a9 00		      lda	#%00000000
    182  f06c		       85 0d		      sta	PF0
    183  f06e		       a9 ff		      lda	#%11111111
    184  f070		       85 0e		      sta	PF1
    185  f072		       a9 ff		      lda	#%11111111
    186  f074		       85 0f		      sta	PF2
    187  f076		       85 81		      sta	LineIdx	; has to count UP
    188  f078
    189  f078		       a9 ff		      lda	#%11111111
    190  f07a		       85 1c		      sta	GRP1
    191  f07c		       a9 70		      lda	#%01110000
    192  f07e		       85 05		      sta	NUSIZ1
    193  f080		       a9 02		      lda	#02
    194  f082		       85 1e		      sta	ENAM1
    195  f084		       85 09		      sta	COLUBK
    196  f086
      0  f086					      TIMER_WAIT
      1  f086				   .waittimer
      2  f086		       ad 84 02 	      lda	INTIM
      3  f089		       d0 fb		      bne	.waittimer
      4  f08b		       85 02		      sta	WSYNC
    198  f08d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
    199  f08d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    200  f08d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
    201  f08d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    202  f08d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    203  f08d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    204  f08d				   OnScreen
      0  f08d					      TIMER_SETUP	195	;214 -- include overscan here.
      1  f08d				   .lines     SET	195
      2  f08d				   .cycles    SET	((.lines * 76) - 13)
      3  f08d
      4  f08d
      5  f08d				  -	      if	(.cycles % 64) < 12
      6  f08d				  -	      lda	#(.cycles / 64) - 1
      7  f08d				  -	      sta	WSYNC
      8  f08d					      else
      9  f08d		       a9 e7		      lda	#(.cycles / 64)
     10  f08f		       85 02		      sta	WSYNC
     11  f091					      endif
     12  f091		       8d 96 02 	      sta	TIM64T
    206  f094							;	ldy #02
    207  f094							;Kernal_Delay_Top
    208  f094							;	dey
    209  f094							;	  sta WSYNC
    210  f094							;	  bne Kernal_Delay_Top
    211  f094							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    212  f094							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
    213  f094		       a9 0a		      lda	#CONS_TILE_ROWS-1
    214  f096		       85 82		      sta	RowIdx
    215  f098							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    216  f098							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
    217  f098				   Kernal_DrawBlocks_Row
    218  f098		       20 a4 f1 	      jsr	setCurrentRowTileColors
    219  f09b		       a0 0a		      ldy	#CONS_TILE_HEIGHT
    220  f09d				   Kernal_DrawBlocks_Col
    221  f09d		       85 02		      sta	WSYNC
    222  f09f		       a5 81		      lda	LineIdx
    223  f0a1		       38		      sec
    224  f0a2		       e5 d4		      sbc	PlayerYPos
    225  f0a4		       c9 02		      cmp	#CONS_PLAYER_HEIGHT
    226  f0a6		       90 07		      bcc	.TurnOnPlayer
    227  f0a8		       a9 00		      lda	#$00
    228  f0aa		       85 1b		      sta	GRP0
    229  f0ac		       4c b6 f0 	      jmp	.DrawPlayfield
    230  f0af				   .TurnOnPlayer
    231  f0af		       a9 ff		      lda	#CONS_PLAYER_WIDTH
    232  f0b1		       85 1b		      sta	GRP0
    233  f0b3		       4c d2 f0 	      jmp	.nextLine
    234  f0b6				   .DrawPlayfield
    235  f0b6					      REPEAT	2	; max 3
    236  f0b6		       a5 c1		      lda	PF_BallStates_Current+5	; does nothing but looks "better"
    235  f0b6					      REPEND
    236  f0b8		       a5 c1		      lda	PF_BallStates_Current+5	; does nothing but looks "better"
    237  f0ba					      REPEND
    238  f0ba				  -	      REPEAT	0	; max 4
    239  f0ba				  -	      nop
    240  f0ba					      REPEND
    241  f0ba		       a5 bc		      lda	PF_BallStates_Current+0
    242  f0bc		       85 08		      sta	COLUPF
    243  f0be		       a5 bd		      lda	PF_BallStates_Current+1
    244  f0c0		       85 08		      sta	COLUPF
    245  f0c2		       a5 be		      lda	PF_BallStates_Current+2
    246  f0c4		       85 08		      sta	COLUPF
    247  f0c6		       a5 bf		      lda	PF_BallStates_Current+3
    248  f0c8		       85 08		      sta	COLUPF
    249  f0ca		       a5 c0		      lda	PF_BallStates_Current+4
    250  f0cc		       85 08		      sta	COLUPF
    251  f0ce							; always black but for timing needs to be here!
    252  f0ce		       a5 c1		      lda	PF_BallStates_Current+5
    253  f0d0		       85 08		      sta	COLUPF
    254  f0d2				   .nextLine
    255  f0d2		       e6 81		      inc	LineIdx
    256  f0d4		       88		      dey
    257  f0d5		       10 c6		      bpl	Kernal_DrawBlocks_Col
    258  f0d7				   .nextSection
    259  f0d7		       c6 82		      dec	RowIdx
    260  f0d9		       10 bd		      bpl	Kernal_DrawBlocks_Row
    261  f0db				   ClearForLauncher
    262  f0db		       a9 00		      lda	#CONS_COLOR_BLACK
    263  f0dd		       85 09		      sta	COLUBK
    264  f0df		       a9 00		      lda	#$00
    265  f0e1		       85 0d		      sta	PF0
    266  f0e3		       85 0e		      sta	PF1
    267  f0e5		       85 0f		      sta	PF2
    268  f0e7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
    269  f0e7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    270  f0e7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
    271  f0e7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    272  f0e7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    273  f0e7							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    274  f0e7		       a2 10		      ldx	#$10
    275  f0e9				   Kernal_Gap_Under_Blocks
    276  f0e9							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    277  f0e9		       85 02		      sta	WSYNC
    278  f0eb		       e6 81		      inc	LineIdx
    279  f0ed		       a5 81		      lda	LineIdx
    280  f0ef		       38		      sec
    281  f0f0		       e5 d4		      sbc	PlayerYPos
    282  f0f2		       c9 01		      cmp	#01
    283  f0f4		       90 05		      bcc	.TurnOnPlayer_2
    284  f0f6		       a9 00		      lda	#$00
    285  f0f8		       4c fd f0 	      jmp	.nextLine_2
    286  f0fb				   .TurnOnPlayer_2
    287  f0fb		       a9 ff		      lda	#$ff
    288  f0fd				   .nextLine_2
    289  f0fd		       85 1b		      sta	GRP0
    290  f0ff		       ca		      dex
    291  f100		       d0 e7		      bne	Kernal_Gap_Under_Blocks
    292  f102		       ea		      nop
    293  f103							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
    294  f103							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    295  f103							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
    296  f103							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    297  f103							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    298  f103		       a9 8d		      lda	#CONS_COLOR_LAUNCHER_BASE
    299  f105		       85 08		      sta	COLUPF
    300  f107		       a9 21		      lda	#%00100001
    301  f109		       85 0a		      sta	CTRLPF
    302  f10b		       a0 0a		      ldy	#CONS_TILE_HEIGHT	; must be this height!
    303  f10d				   Kernal_Launcher
    304  f10d							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    305  f10d		       85 02		      sta	WSYNC
    306  f10f		       a9 02		      lda	#$02
    307  f111		       85 1f		      sta	ENABL
    308  f113		       88		      dey
    309  f114		       d0 f7		      bne	Kernal_Launcher
    310  f116							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
    311  f116		       a9 00		      lda	#$00
    312  f118		       85 1f		      sta	ENABL
    313  f11a		       a9 8d		      lda	#CONS_COLOR_LAUNCHER_BASE
    314  f11c		       85 08		      sta	COLUPF
    315  f11e		       a0 08		      ldy	#$08
    316  f120				   Kernal_Launcher_Base
    317  f120							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    318  f120		       85 02		      sta	WSYNC
    319  f122		       88		      dey
    320  f123		       d0 fb		      bne	Kernal_Launcher_Base
    321  f125							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    322  f125				   Kernal_End
    323  f125							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    324  f125		       a9 00		      lda	#CONS_COLOR_BLACK
    325  f127		       85 08		      sta	COLUPF
    326  f129		       a9 00		      lda	#$00
    327  f12b		       85 1b		      sta	GRP0
    328  f12d		       85 1c		      sta	GRP1
    329  f12f		       85 1e		      sta	ENAM1
    330  f131
    331  f131		       a5 dd		      lda	PlayerState
    332  f133							;cmp #CONS_PLAYER_STATE_COLLISION_CHECK
    333  f133							; beq .checkCollision
    334  f133							;cmp #CONS_PLAYER_STATE_COLLISION_SET
    335  f133							;beq .setCollision
    336  f133		       c9 01		      cmp	#CONS_PLAYER_STATE_MOVING
    337  f135		       f0 06		      beq	.moveBall
    338  f137				   .readUserImport
    339  f137		       20 9a f2 	      jsr	MoveJoystick
    340  f13a		       4c 50 f1 	      jmp	OffScreen
    341  f13d				   .moveBall
    342  f13d		       20 c6 f1 	      jsr	setBallPosition
    343  f140		       a9 02		      lda	#CONS_PLAYER_STATE_COLLISION_CHECK
    344  f142							;jmp OffScreen
    345  f142				   .checkCollision
    346  f142		       20 04 f2 	      jsr	getCollision
    347  f145							;lda #CONS_PLAYER_STATE_COLLISION_SET
    348  f145							;jmp OffScreen
    349  f145				   .setCollision
    350  f145		       a5 dc		      lda	PlayerColor+1
    351  f147		       c9 00		      cmp	#CONS_COLOR_BLACK
    352  f149		       f0 03		      beq	.skipSetCollision
    353  f14b		       20 63 f2 	      jsr	setCollision
    354  f14e				   .skipSetCollision
    355  f14e		       a9 01		      lda	#CONS_PLAYER_STATE_MOVING
    356  f150							;jmp OffScreen ; TODO -- not needed but keeps things clean
    357  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
    358  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
    359  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
    360  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    361  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    362  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    363  f150				   OffScreen
    364  f150							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    365  f150		       85 dd		      sta	PlayerState
    366  f152		       ea		      nop
      0  f153					      TIMER_WAIT
      1  f153				   .waittimer
      2  f153		       ad 84 02 	      lda	INTIM
      3  f156		       d0 fb		      bne	.waittimer
      4  f158		       85 02		      sta	WSYNC
    368  f15a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    369  f15a							; Overscan
    370  f15a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    371  f15a							; 29 lines of overscan
      0  f15a					      TIMER_SETUP	29	;29
      1  f15a				   .lines     SET	29
      2  f15a				   .cycles    SET	((.lines * 76) - 13)
      3  f15a
      4  f15a
      5  f15a				  -	      if	(.cycles % 64) < 12
      6  f15a				  -	      lda	#(.cycles / 64) - 1
      7  f15a				  -	      sta	WSYNC
      8  f15a					      else
      9  f15a		       a9 22		      lda	#(.cycles / 64)
     10  f15c		       85 02		      sta	WSYNC
     11  f15e					      endif
     12  f15e		       8d 96 02 	      sta	TIM64T
    373  f161		       ea		      nop
      0  f162					      TIMER_WAIT
      1  f162				   .waittimer
      2  f162		       ad 84 02 	      lda	INTIM
      3  f165		       d0 fb		      bne	.waittimer
      4  f167		       85 02		      sta	WSYNC
    375  f169							; total = 262 lines, go to next frame
    376  f169		       4c 48 f0 	      jmp	NextFrame
    377  f16c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    378  f16c							; Subroutines
    379  f16c							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    380  f16c							; SetHorizPos routine
    381  f16c							; A = X coordinate
    382  f16c							; X = player number (0 or 1)
    383  f16c				   SetHorizPos
    384  f16c		       85 02		      sta	WSYNC	; start a new line
    385  f16e		       38		      sec		; set carry flag
    386  f16f				   DivideLoop
    387  f16f		       e9 0f		      sbc	#15	; subtract 15
    388  f171		       b0 fc		      bcs	DivideLoop	; branch until negative
    389  f173		       49 07		      eor	#7	; calculate fine offset
    390  f175		       0a		      asl
    391  f176		       0a		      asl
    392  f177		       0a		      asl
    393  f178		       0a		      asl
    394  f179		       95 10		      sta	RESP0,x	; fix coarse position
    395  f17b		       95 20		      sta	HMP0,x	; set fine offset
    396  f17d		       85 02		      sta	WSYNC
    397  f17f		       85 2a		      sta	HMOVE	; apply the previous fine position(s)
    398  f181		       85 2b		      sta	HMCLR	; reset the old horizontal position(s)
    399  f183		       60		      rts		; return to caller
    400  f184				   setXPositionsForObjects
    401  f184		       a5 cd		      lda	PlayerXPos	; get X coordinate
    402  f186		       a2 00		      ldx	#0	; player 0
    403  f188		       20 6c f1 	      jsr	SetHorizPos	; set coarse offset
    404  f18b
    405  f18b
    406  f18b		       a9 1d		      lda	#CONS_LEFT_WALL-9	; get X coordinate
    407  f18d		       a2 01		      ldx	#1
    408  f18f		       20 6c f1 	      jsr	SetHorizPos
    409  f192
    410  f192							;TODO --- cannot use player 0 missle as a border, our color will change!!
    411  f192		       a9 85		      lda	#CONS_RIGHT_WALL+10	; get X coordinate
    412  f194		       a2 03		      ldx	#3
    413  f196		       20 6c f1 	      jsr	SetHorizPos
    414  f199
    415  f199		       a9 50		      lda	#CONS_LAUNCH_START_X+3	; get X coordinate
    416  f19b		       a2 04		      ldx	#4
    417  f19d		       20 6c f1 	      jsr	SetHorizPos
    418  f1a0
    419  f1a0		       85 02		      sta	WSYNC	; sync w/ scanline
    420  f1a2		       85 2a		      sta	HMOVE	; apply fine offsets	
    421  f1a4				   setCurrentRowTileColors
    422  f1a4							; get the row we will want to store it in current
    423  f1a4		       a6 82		      ldx	RowIdx
    424  f1a6		       b4 c2		      ldy	PF_RowIndexes,x
    425  f1a8		       b9 85 00 	      lda	PF_BallStates_All,y
    426  f1ab		       85 bc		      sta	PF_BallStates_Current
    427  f1ad		       b9 86 00 	      lda	PF_BallStates_All,y+1
    428  f1b0		       85 bd		      sta	PF_BallStates_Current+1
    429  f1b2		       b9 87 00 	      lda	PF_BallStates_All,y+2
    430  f1b5		       85 be		      sta	PF_BallStates_Current+2
    431  f1b7		       b9 88 00 	      lda	PF_BallStates_All,y+3
    432  f1ba		       85 bf		      sta	PF_BallStates_Current+3
    433  f1bc		       b9 89 00 	      lda	PF_BallStates_All,y+4
    434  f1bf		       85 c0		      sta	PF_BallStates_Current+4
    435  f1c1		       a9 00		      lda	#CONS_COLOR_BLACK
    436  f1c3		       85 c1		      sta	PF_BallStates_Current+5
    437  f1c5		       60		      rts
    438  f1c6							;-----------------------------------------
    439  f1c6				   setBallPosition
    440  f1c6		       c6 d7		      dec	Tick_PlayerY_Step
    441  f1c8		       d0 13		      bne	.stepXPosTick
    442  f1ca		       a4 d8		      ldy	Tick_PlayerY_Step+1
    443  f1cc		       84 d7		      sty	Tick_PlayerY_Step
    444  f1ce		       38		      sec
    445  f1cf				   .changeYPos
    446  f1cf		       a5 d4		      lda	PlayerYPos
    447  f1d1		       e5 d6		      sbc	PlayerDirY
    448  f1d3		       85 d4		      sta	PlayerYPos
    449  f1d5		       c9 00		      cmp	#CONS_TOP_WALL
    450  f1d7		       10 04		      bpl	.stepXPosTick
    451  f1d9							;lda #00
    452  f1d9							;sta PlayerDirY
    453  f1d9		       a9 78		      lda	#CONS_TOP_WALL+(#CONS_TILE_HEIGHT*12)+0
    454  f1db		       85 d4		      sta	PlayerYPos
    455  f1dd							;-----------------------------------------
    456  f1dd				   .stepXPosTick
    457  f1dd		       c6 d0		      dec	Tick_PlayerX_Step
    458  f1df		       d0 22		      bne	.endBallPosition
    459  f1e1		       a4 d1		      ldy	Tick_PlayerX_Step+1
    460  f1e3		       84 d0		      sty	Tick_PlayerX_Step
    461  f1e5				   .changeXPos
    462  f1e5		       a5 cd		      lda	PlayerXPos
    463  f1e7		       18		      clc
    464  f1e8		       65 cf		      adc	PlayerDirX
    465  f1ea				   .checkLeftBoundry
    466  f1ea		       c9 26		      cmp	#CONS_LEFT_WALL
    467  f1ec		       b0 09		      bcs	.checkRightBoundry
    468  f1ee		       a9 09		      lda	#CONS_PLAYER_SPEED_X
    469  f1f0		       85 cf		      sta	PlayerDirX
    470  f1f2		       a9 2f		      lda	#CONS_LEFT_WALL+#CONS_PLAYER_SPEED_X
    471  f1f4		       4c 01 f2 	      jmp	.endXPosition
    472  f1f7				   .checkRightBoundry
    473  f1f7		       c9 7b		      cmp	#CONS_RIGHT_WALL
    474  f1f9		       90 06		      bcc	.endXPosition
    475  f1fb		       a9 f7		      lda	#$00-CONS_PLAYER_SPEED_X
    476  f1fd		       85 cf		      sta	PlayerDirX
    477  f1ff		       a9 72		      lda	#CONS_RIGHT_WALL-#CONS_PLAYER_SPEED_X
    478  f201				   .endXPosition
    479  f201		       85 cd		      sta	PlayerXPos
    480  f203				   .endBallPosition
    481  f203		       60		      rts
    482  f204							; Possibly add BACK set Boundries so we aren't pulling based on the pointer every time?
    483  f204							;-----------------------------------------
    484  f204				   getCollision
    485  f204				   .checkRowCollision
    486  f204		       18		      clc
    487  f205		       a5 d4		      lda	PlayerYPos
    488  f207		       a0 00		      ldy	#$00
    489  f209				   .findRowCurrent
    490  f209		       e9 0a		      sbc	#CONS_TILE_HEIGHT
    491  f20b		       90 04		      bcc	.storeRowCurrent
    492  f20d		       c8		      iny
    493  f20e		       4c 09 f2 	      jmp	.findRowCurrent
    494  f211				   .storeRowCurrent
    495  f211		       84 d2		      sty	PlayerRow
    496  f213		       a5 d7		      lda	Tick_PlayerY_Step
    497  f215		       c9 01		      cmp	#01
    498  f217		       d0 10		      bne	.storeNextRow	; otherwise we skip to the COL stuff
    499  f219		       18		      clc
    500  f21a		       a5 d4		      lda	PlayerYPos
    501  f21c		       e5 d6		      sbc	PlayerDirY
    502  f21e		       18		      clc
    503  f21f		       a0 00		      ldy	#$00
    504  f221				   .findRowNext
    505  f221		       e9 0a		      sbc	#CONS_TILE_HEIGHT
    506  f223		       90 04		      bcc	.storeNextRow
    507  f225		       c8		      iny
    508  f226		       4c 21 f2 	      jmp	.findRowNext
    509  f229				   .storeNextRow
    510  f229		       84 d3		      sty	PlayerRow+1	; -- todo THIS is wrong!
    511  f22b							;-----
    512  f22b				   .checkColCollision
    513  f22b		       18		      clc
    514  f22c		       a5 cd		      lda	PlayerXPos
    515  f22e		       a0 00		      ldy	#$00
    516  f230				   .findColCurrent
    517  f230		       e9 11		      sbc	#CONS_TILE_WIDTH
    518  f232		       c9 26		      cmp	#CONS_LEFT_WALL
    519  f234		       90 04		      bcc	.storeColCurrent
    520  f236		       c8		      iny
    521  f237		       4c 30 f2 	      jmp	.findColCurrent
    522  f23a				   .storeColCurrent
    523  f23a		       84 d9		      sty	PlayerCol
    524  f23c		       a5 d0		      lda	Tick_PlayerX_Step
    525  f23e		       c9 01		      cmp	#01
    526  f240		       d0 12		      bne	.storeNextCol	; otherwise we skip to the COL stuff
    527  f242		       18		      clc
    528  f243		       a5 cd		      lda	PlayerXPos
    529  f245		       65 cf		      adc	PlayerDirX
    530  f247		       18		      clc
    531  f248		       a0 00		      ldy	#$00
    532  f24a				   .findColNext
    533  f24a		       e9 11		      sbc	#CONS_TILE_WIDTH
    534  f24c		       c9 26		      cmp	#CONS_LEFT_WALL
    535  f24e		       90 04		      bcc	.storeNextCol
    536  f250		       c8		      iny
    537  f251		       4c 4a f2 	      jmp	.findColNext
    538  f254				   .storeNextCol
    539  f254		       84 da		      sty	PlayerCol+1
    540  f256				   .getNextColor
    541  f256		       18		      clc
    542  f257		       98		      tya
    543  f258		       a4 d3		      ldy	PlayerRow+1
    544  f25a		       79 c2 00 	      adc	PF_RowIndexes,y
    545  f25d		       b9 85 00 	      lda	PF_BallStates_All,y
    546  f260		       85 dc		      sta	PlayerColor+1
    547  f262		       60		      rts
    548  f263							;-----------------------------------------
    549  f263				   setCollision
    550  f263		       a5 d9		      lda	PlayerCol
    551  f265		       a4 d2		      ldy	PlayerRow
    552  f267				   .multiplyByRow_Set
    553  f267		       c0 00		      cpy	#00
    554  f269		       f0 07		      beq	.setColorHere
    555  f26b		       88		      dey
    556  f26c		       18		      clc
    557  f26d		       69 05		      adc	#CONS_TILE_COLS
    558  f26f		       4c 67 f2 	      jmp	.multiplyByRow_Set
    559  f272				   .setColorHere
    560  f272		       a8		      tay
    561  f273		       a9 3c		      lda	#CONS_COLOR_PINK
    562  f275		       99 85 00 	      sta	PF_BallStates_All,y
    563  f278		       60		      rts
    564  f279							;-----------------------------------------
    565  f279				   spawnBallAtLauncher
    566  f279							; Set player positions
    567  f279		       a9 c6		      lda	#CONS_COLOR_GREEN	; TODO -- set to color of current ball
    568  f27b		       85 06		      sta	COLUP0
    569  f27d		       a9 6d		      lda	#CONS_LEFT_WALL+#71	;#CONS_LAUNCH_START_X
    570  f27f		       85 cd		      sta	PlayerXPos
    571  f281		       a9 f7		      lda	#$00-CONS_PLAYER_SPEED_X
    572  f283		       85 cf		      sta	PlayerDirX
    573  f285		       a9 01		      lda	#01
    574  f287		       85 d0		      sta	Tick_PlayerX_Step
    575  f289		       85 d1		      sta	Tick_PlayerX_Step+1
    576  f28b							;---------------
    577  f28b		       a9 8f		      lda	#CONS_LAUNCH_START_Y
    578  f28d		       85 d4		      sta	PlayerYPos
    579  f28f		       a9 02		      lda	#CONS_PLAYER_SPEED_Y
    580  f291		       85 d6		      sta	PlayerDirY
    581  f293		       a9 01		      lda	#01
    582  f295		       85 d7		      sta	Tick_PlayerY_Step
    583  f297		       85 d8		      sta	Tick_PlayerY_Step+1
    584  f299		       60		      rts
    585  f29a							;-----------------------------------------
    586  f29a							; SWCHA -- directional register
    587  f29a							; #%10000000 -- P1 Right
    588  f29a							; #%01000000 -- P1 left
    589  f29a							; #%00100000 -- P1 down
    590  f29a							; #%00010000 -- P1 up
    591  f29a							; #%00001000 -- P0 Right
    592  f29a							; #%00000100 -- P0 left
    593  f29a							; #%00000010 -- P0 down
    594  f29a							; #%00000001 -- P0 up
    595  f29a							; 
    596  f29a				   MoveJoystick
    597  f29a		       a9 40		      lda	#%01000000
    598  f29c		       2c 80 02 	      bit	SWCHA	; Read Joystick directions
    599  f29f		       d0 00		      bne	.checkRight	; If 0, Left is pressed
    600  f2a1				   .checkRight
    601  f2a1		       a9 80		      lda	#%10000000
    602  f2a3		       2c 80 02 	      bit	SWCHA	; Mask for Bit 7
    603  f2a6		       d0 00		      bne	.checkbutton	; If 0, Right is pressed
    604  f2a8				   .checkbutton
    605  f2a8		       a9 40		      lda	#%01000000	; -- should be byte 7, if that is the case we move this to above the direction!
    606  f2aa		       24 0c		      bit	INPT4	; Read Fire Button (Bit 7)
    607  f2ac		       d0 01		      bne	.endJoystickCheck	; If BIT 7 is 1 (Negative), button is released
    608  f2ae		       ea		      nop
    609  f2af				   .endJoystickCheck
    610  f2af		       60		      rts
    611  f2b0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    612  f2b0
    613  f2b0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    614  f2b0							; Data
    615  f2b0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    616  f300		       00 00 00 00*	      align	$100
    617  f300				   PF_Level_Colors
    618  f300		       46		      .byte.b	#CONS_COLOR_RED
    619  f301		       38		      .byte.b	#CONS_COLOR_ORANGE
    620  f302		       1e		      .byte.b	#CONS_COLOR_YELLOW
    621  f303		       c6		      .byte.b	#CONS_COLOR_GREEN
    622  f304		       64		      .byte.b	#CONS_COLOR_PURPLE
    623  f305		       a6		      .byte.b	#CONS_COLOR_BLUE
    624  f306							;-----------------------------------------
    625  f306				   PF_Boundries_Row
    626  f306		       0a		      .byte.b	#(CONS_TILE_HEIGHT)*1
    627  f307		       14		      .byte.b	#(CONS_TILE_HEIGHT)*2
    628  f308		       1e		      .byte.b	#(CONS_TILE_HEIGHT)*3
    629  f309		       28		      .byte.b	#(CONS_TILE_HEIGHT)*4
    630  f30a		       32		      .byte.b	#(CONS_TILE_HEIGHT)*5
    631  f30b		       3c		      .byte.b	#(CONS_TILE_HEIGHT)*6
    632  f30c		       46		      .byte.b	#(CONS_TILE_HEIGHT)*7
    633  f30d		       50		      .byte.b	#(CONS_TILE_HEIGHT)*8
    634  f30e		       5a		      .byte.b	#(CONS_TILE_HEIGHT)*9
    635  f30f		       64		      .byte.b	#(CONS_TILE_HEIGHT)*10
    636  f310		       6e		      .byte.b	#(CONS_TILE_HEIGHT)*11
    637  f311		       78		      .byte.b	#(CONS_TILE_HEIGHT)*12
    638  f312				   PF_Boundries_Col
    639  f312		       37		      .byte.b	#(CONS_LEFT_WALL+17)
    640  f313		       49		      .byte.b	#(CONS_LEFT_WALL+35)
    641  f314		       5b		      .byte.b	#(CONS_LEFT_WALL+53)
    642  f315		       6d		      .byte.b	#(CONS_LEFT_WALL+71)
    643  f316							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    644  f316							; Epilogue
    645  f316							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    646  fffc					      org	$fffc
    647  fffc		       00 f0		      .word.w	Start	; reset vector
    648  fffe		       00 f0		      .word.w	Start	; BRK vector
