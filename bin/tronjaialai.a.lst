------- FILE tronjaialai.a LEVEL 1 PASS 2
      1  10000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      2  10000 ????						; Header
      3  10000 ????				       processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.05, 13/November/2003
      3  10000 ????
      4  10000 ????		00 69	    VERSION_VCS =	105
      5  10000 ????
      6  10000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at http://www.atari2600.org/dasm
     14  10000 ????						;
     15  10000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  10000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  10000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  10000 ????						; with your views.  Please contribute, if you think you can improve this
     19  10000 ????						; file!
     20  10000 ????						;
     21  10000 ????						; Latest Revisions...
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE tronjaialai.a
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.06, 3/SEPTEMBER/2004
      3  0000 ????
      4  0000 ????	       00 6a	   VERSION_MACRO =	106
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	22/MAR/2003		Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Andrew Davie
     97  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
     98  0000 ????						; Sets stack pointer to $FF, and all registers to 0
     99  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    100  0000 ????						; Use as very first section of code on boot (ie: at reset)
    101  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    102  0000 ????
    103  0000 ????				      MAC	clean_start
    104  0000 ????				      sei
    105  0000 ????				      cld
    106  0000 ????
    107  0000 ????				      ldx	#0
    108  0000 ????				      txa
    109  0000 ????				      tay
    110  0000 ????			   .CLEAR_STACK dex
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    114  0000 ????
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????						;-------------------------------------------------------
    163  0000 ????						; SKIP_SCANLINES #lines
    164  0000 ????						;
    165  0000 ????						; Skip a given # of scanlines.
    166  0000 ????						; Sets the X register to zero.
    167  0000 ????
    168  0000 ????				      MAC	skip_scanlines
    169  0000 ????			   .LINES     SET	{1}
    170  0000 ????				      ldx	#.LINES
    171  0000 ????			   .vblank    sta	WSYNC
    172  0000 ????				      dex
    173  0000 ????				      bne	.vblank
    174  0000 ????				      ENDM
    175  0000 ????
    176  0000 ????						; EOF
------- FILE tronjaialai.a
      6  0000 ????						; include "custom_macro.h" ; -- do so much work online this seems nice but necessary atm
------- FILE xmacro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"xmacro.h"
      1  0000 ????
      2  0000 ????						;-------------------------------------------------------
      3  0000 ????						; Usage: TIMER_SETUP lines
      4  0000 ????						; where lines is the number of scanlines to skip (> 2).
      5  0000 ????						; The timer will be set so that it expires before this number
      6  0000 ????						; of scanlines. A WSYNC will be done first.
      7  0000 ????
      8  0000 ????				      MAC	timer_setup
      9  0000 ????			   .lines     SET	{1}
     10  0000 ????			   .cycles    SET	((.lines * 76) - 13)
     11  0000 ????						; special case for when we have two timer events in a line
     12  0000 ????						; and our 2nd event straddles the WSYNC boundary
     13  0000 ????				      if	(.cycles % 64) < 12
     14  0000 ????				      lda	#(.cycles / 64) - 1
     15  0000 ????				      sta	WSYNC
     16  0000 ????				      else
     17  0000 ????				      lda	#(.cycles / 64)
     18  0000 ????				      sta	WSYNC
     19  0000 ????				      endif
     20  0000 ????				      sta	TIM64T
     21  0000 ????				      ENDM
     22  0000 ????
     23  0000 ????						;-------------------------------------------------------
     24  0000 ????						; Use with TIMER_SETUP to wait for timer to complete.
     25  0000 ????						; Performs a WSYNC afterwards.
     26  0000 ????
     27  0000 ????				      MAC	timer_wait
     28  0000 ????			   .waittimer
     29  0000 ????				      lda	INTIM
     30  0000 ????				      bne	.waittimer
     31  0000 ????				      sta	WSYNC
     32  0000 ????				      ENDM
------- FILE tronjaialai.a
      8  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      9  0000 ????						; Constants
     10  0000 ????	       00 f2	   CONS_PLAYER_HEIGHT EQU	$F2	; FF-intended height
     11  0000 ????	       00 0f	   CONS_TILE_HEIGHT EQU	#15
     12  0000 ????	       00 00	   CONS_TILE_HIDE EQU	%00000000
     13  0000 ????
     14  0000 ????	       00 00	   CONS_COLOR_BLACK EQU	$00
     15  0000 ????	       00 40	   CONS_COLOR_RED EQU	$40
     16  0000 ????	       00 4a	   CONS_COLOR_PINK EQU	$4A
     17  0000 ????	       00 82	   CONS_COLOR_BLUE EQU	$82
     18  0000 ????	       00 8d	   CONS_COLOR_TEAL EQU	$8D
     19  0000 ????	       00 c6	   CONS_COLOR_GREEN EQU	$C6
     20  0000 ????	       00 ca	   CONS_COLOR_CHART EQU	$CA
     21  0000 ????
     22  0000 ????	       00 07	   CONS_BOUNDRY_P0_LEFT EQU	#7
     23  0000 ????	       00 06	   CONS_BOUNDRY_P0_RIGHT EQU	#6
     24  0000 ????	       00 06	   CONS_BOUNDRY_P1_LEFT EQU	#6
     25  0000 ????	       00 9c	   CONS_BOUNDRY_P1_RIGHT EQU	#156
     26  0000 ????	       00 9e	   CONS_BOUNDRY_BOTTOM EQU	#158
     27  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     28  0000 ????						; Macros
     29  0000 ????						; TODO add to includes
     30  0000 ????						;--------
     31  0000 ????						; FLIP_BOOL duration
     32  0000 ????						; Original author: Andy Garber
     33  0000 ????						; Takes a memory address and flips it's value than stores it
     34  0000 ????						; Assumes the Memory address value is 1 or 0
     35  0000 ????						;usage: FLIP_BOOL SomeAddress
     36  0000 ????				      MAC	flip_bool
     37  0000 ????			   .MEMADDR   SET	{1}
     38  0000 ????				      lda	.MEMADDR
     39  0000 ????				      EOR	#$01
     40  0000 ????				      sta	.MEMADDR
     41  0000 ????				      ENDM
     42  0000 ????						;--------
     43  0000 ????						; CLEAR_PLAYFIELD duration
     44  0000 ????						; Original author: Andy Garber
     45  0000 ????						; sets playfield to 0 across the board
     46  0000 ????				      MAC	clear_playfield
     47  0000 ????				      lda	#%00000000
     48  0000 ????				      sta	PF0
     49  0000 ????				      sta	PF1
     50  0000 ????				      sta	PF2
     51  0000 ????				      ENDM
     52  0000 ????
     53  0000 ????						;--------
     54  0000 ????						; FILL_PLAYFIELD duration
     55  0000 ????						; Original author: Andy Garber
     56  0000 ????						; sets playfield to 1 across the board
     57  0000 ????				      MAC	fill_playfield
     58  0000 ????				      lda	#%11111111
     59  0000 ????				      sta	PF0
     60  0000 ????				      sta	PF1
     61  0000 ????				      sta	PF2
     62  0000 ????				      ENDM
     63  0000 ????
     64  0000 ????						;--------
     65  0000 ????						; DRAW_PLAYER duration
     66  0000 ????						; Original author: Andy Garber
     67  0000 ????						; Draws a player based on the lineIdx var
     68  0000 ????				      MAC	draw_player
     69  0000 ????			   .YPOS      SET	{1}
     70  0000 ????			   .HEIGHT    SET	{2}
     71  0000 ????			   .PLAYER_REG SET	{3}
     72  0000 ????			   .PLAYER_PTR SET	{4}
     73  0000 ????			   .PLAYER_IDX SET	{5}
     74  0000 ????				      ldy	.PLAYER_PTR
     75  0000 ????				      lda	.YPOS
     76  0000 ????				      SBC	LineIdx
     77  0000 ????				      BPL	.skip
     78  0000 ????				      CMP	#.HEIGHT
     79  0000 ????				      BMI	.skip
     80  0000 ????				      lda	(.PLAYER_PTR),y
     81  0000 ????				      inc	.PLAYER_IDX
     82  0000 ????				      jmp	.end
     83  0000 ????			   .skip
     84  0000 ????				      lda	#%0000000
     85  0000 ????			   .end
     86  0000 ????				      sta	.PLAYER_REG
     87  0000 ????				      ENDM
     88  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     89  0000 ????
     90  0000 ????						; Variables segment
     91 U009f ????				      seg.u	Variables
     92 U0080					      org	$80
     93 U0080
     94 U0080		       00	   DrawCycle  .byte.b		;-- what cycle of our draws we are on
     95 U0081							; 1: Draw playfield
     96 U0081							; 2: Draw Players
     97 U0081		       00	   DrawPlayer .byte.b		;-- what cycle of our draws we are on
     98 U0082							; 1: Draw playfield
     99 U0082							; 2: Draw Players
    100 U0082		       00	   ReadJoystick .byte.b
    101 U0083
    102 U0083		       00	   LineIdx    .byte.b
    103 U0084
    104 U0084		       00	   loopIntI   .byte.b
    105 U0085		       00	   loopIntJ   .byte.b
    106 U0086		       00	   loopIntK   .byte.b
    107 U0087
    108 U0087		       00 00 00 00*p0_TileBooleans .DS	6
    109 U008d		       00 00 00 00*p1_TileBooleans .DS	6
    110 U0093
    111 U0093		       00	   P0XPos     .byte.b		;-- X coordinates
    112 U0094		       00	   P1XPos     .byte.b
    113 U0095
    114 U0095		       00	   P0YPos     .byte.b		;-- Y coordinate (offset from the start of the playfield)
    115 U0096		       00	   P1YPos     .byte.b
    116 U0097
    117 U0097		       00	   P0Idx      .byte.b		;-- data index of our sprite data
    118 U0098		       00	   P1Idx      .byte.b
    119 U0099
    120 U0099		       00	   P0CIdx     .byte.b		;-- color index of our sprite data
    121 U009a		       00	   P1CIdx     .byte.b
    122 U009b
    123 U009b		       00 00	   P0Ptr      .DS	2
    124 U009d		       00 00	   P1Ptr      .DS	2
    125 U009f							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    126 U009f							; Code segment
    127  10000 ????				       seg	Code
    128  f000					      org	$f000
    129  f000
    130  f000				   Start
      0  f000					      CLEAN_START
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002		       a2 00		      ldx	#0
      5  f004		       8a		      txa
      6  f005		       a8		      tay
      7  f006		       ca	   .CLEAR_STACK dex
      8  f007		       9a		      txs
      9  f008		       48		      pha
     10  f009		       d0 fb		      bne	.CLEAR_STACK
     11  f00b
    132  f00b
    133  f00b		       a2 05		      ldx	#05
    134  f00d				   init_PF_Tiles
    135  f00d		       a9 82		      lda	#CONS_COLOR_BLUE
    136  f00f		       95 87		      sta	p0_TileBooleans,x
    137  f011		       95 8d		      sta	p1_TileBooleans,x
    138  f013		       ca		      dex
    139  f014		       10 f7		      bpl	init_PF_Tiles
    140  f016		       a9 01		      lda	#$01
    141  f018		       85 0a		      sta	CTRLPF
    142  f01a							;lda #CONS_COLOR_BLACK ; for debug
    143  f01a							;sta p0_TileBooleans+5
    144  f01a							;sta p1_TileBooleans+5
    145  f01a				   init_Players
    146  f01a		       a9 07		      lda	#CONS_BOUNDRY_P0_LEFT	; Max Left
    147  f01c		       85 93		      sta	P0XPos
    148  f01e		       a9 9c		      lda	#CONS_BOUNDRY_P1_RIGHT	; Max right
    149  f020		       85 94		      sta	P1XPos
    150  f022		       a9 01		      lda	#1
    151  f024		       85 95		      sta	P0YPos
    152  f026		       85 96		      sta	P1YPos
    153  f028		       a9 00		      lda	#0
    154  f02a		       85 97		      sta	P0Idx
    155  f02c		       85 98		      sta	P1Idx
    156  f02e
    157  f02e		       a9 ee		      lda	#<P0_Frame_0	; I flipped this
    158  f030		       85 9b		      sta	P0Ptr
    159  f032		       a9 f1		      lda	#>P0_Frame_0	; I flipped this
    160  f034		       85 9c		      sta	P0Ptr+1
    161  f036
    162  f036		       a9 fc		      lda	#<P1_Frame_0	; I flipped this
    163  f038		       85 9d		      sta	P1Ptr
    164  f03a		       a9 f1		      lda	#>P0_Frame_0	; I flipped this
    165  f03c		       85 9e		      sta	P1Ptr+1
    166  f03e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    167  f03e							; Main
    168  f03e				   NextFrame
    169  f03e		       4e 82 02 	      lsr	SWCHB	; test Game Reset switch
    170  f041		       90 bd		      bcc	Start	; reset?
    171  f043							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    172  f043				   Kernal_PreScreen
    173  f043							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      0  f043					      VERTICAL_SYNC		; 1 + 3 lines of VSYNC
      1  f043		       a9 0e		      lda	#%1110
      2  f045		       85 02	   .VSLP1     sta	WSYNC
      3  f047		       85 00		      sta	VSYNC
      4  f049		       4a		      lsr
      5  f04a		       d0 f9		      bne	.VSLP1
      0  f04c					      TIMER_SETUP	37	; 37 lines of underscan
      1  f04c				   .lines     SET	37
      2  f04c				   .cycles    SET	((.lines * 76) - 13)
      3  f04c
      4  f04c
      5  f04c				  -	      if	(.cycles % 64) < 12
      6  f04c				  -	      lda	#(.cycles / 64) - 1
      7  f04c				  -	      sta	WSYNC
      8  f04c					      else
      9  f04c		       a9 2b		      lda	#(.cycles / 64)
     10  f04e		       85 02		      sta	WSYNC
     11  f050					      endif
     12  f050		       8d 96 02 	      sta	TIM64T
    176  f053
    177  f053							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    178  f053				   Kernal_Screen
    179  f053							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;      
      0  f053					      CLEAR_PLAYFIELD
      1  f053		       a9 00		      lda	#%00000000
      2  f055		       85 0d		      sta	PF0
      3  f057		       85 0e		      sta	PF1
      4  f059		       85 0f		      sta	PF2
    181  f05b		       a9 4a		      lda	#CONS_COLOR_PINK
    182  f05d		       85 06		      sta	COLUP0
    183  f05f		       a9 ca		      lda	#CONS_COLOR_CHART
    184  f061		       85 07		      sta	COLUP1
    185  f063		       a9 00		      lda	#CONS_COLOR_BLACK
    186  f065		       85 09		      sta	COLUBK
    187  f067		       a9 ff		      lda	#255
    188  f069		       85 83		      sta	LineIdx
    189  f06b
      0  f06b					      TIMER_WAIT
      1  f06b				   .waittimer
      2  f06b		       ad 84 02 	      lda	INTIM
      3  f06e		       d0 fb		      bne	.waittimer
      4  f070		       85 02		      sta	WSYNC
    191  f072
    192  f072							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    193  f072							;		 Main (192 lines)
    194  f072							; What is a Kernal?
    195  f072							; These are groupings of line sections.
    196  f072							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
    197  f072				   Kernal_Movement
    198  f072							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
    199  f072							; This is where we do player X logic
    200  f072							; Set Player 1 x position
    201  f072		       a5 93		      lda	P0XPos	; get X coordinate
    202  f074		       a2 00		      ldx	#0	; player 0
    203  f076		       20 a0 f1 	      jsr	SetHorizPos	; set coarse offset
    204  f079		       85 02		      sta	WSYNC	; sync w/ scanline
    205  f07b		       85 2a		      sta	HMOVE	; apply fine offsets
    206  f07d
    207  f07d		       a5 94		      lda	P1XPos	; get X coordinate
    208  f07f		       a2 01		      ldx	#1	; player 1
    209  f081		       20 a0 f1 	      jsr	SetHorizPos	; set coarse offset
    210  f084		       85 02		      sta	WSYNC	; sync w/ scanline
    211  f086		       85 2a		      sta	HMOVE	; apply fine offsets
    212  f088
    213  f088		       a9 00		      lda	#0
    214  f08a		       85 97		      sta	P0Idx
    215  f08c		       85 98		      sta	P1Idx
    216  f08e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
    217  f08e		       85 02		      sta	WSYNC
    218  f090				   Kernal_Tower
    219  f090							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
    220  f090							; Background art for the upper half of the game.
    221  f090							; PF is set to Mirror and we just draw. than wait
    222  f090							; The BLACK we see is really the PF mirroed.
    223  f090							; Color of the towers is controlled by the background.
    224  f090		       a9 00		      lda	#CONS_COLOR_BLACK	; Make this a define
    225  f092		       85 08		      sta	COLUPF
    226  f094		       a2 00		      ldx	#$0
    227  f096		       a0 48		      ldy	#$48
    228  f098		       85 02		      sta	WSYNC
    229  f09a				   Kernal_Tower_Draw
    230  f09a							;sta WSYNC
    231  f09a		       a2 00		      ldx	#$0
    232  f09c		       c0 48		      cpy	#$48
    233  f09e		       30 0f		      bmi	Kernal_Tower_Draw_Colorize
    234  f0a0							;	  .byte #%11110000
    235  f0a0							;.byte #%11110111
    236  f0a0							;.byte #%01111111
    237  f0a0							;
    238  f0a0							;
    239  f0a0		       e8		      inx
    240  f0a1		       a9 f0		      lda	#%11110000	;PF_Kernal_Tower,x
    241  f0a3		       85 0d		      sta	PF0
    242  f0a5
    243  f0a5		       e8		      inx
    244  f0a6		       a9 f7		      lda	#%11110111	;PF_Kernal_Tower,x
    245  f0a8		       85 0e		      sta	PF1
    246  f0aa
    247  f0aa		       e8		      inx
    248  f0ab		       a9 7f		      lda	#%01111111	;PF_Kernal_Tower,x;#%01111111
    249  f0ad		       85 0f		      sta	PF2
    250  f0af				   Kernal_Tower_Draw_Colorize
    251  f0af		       a9 40		      lda	#CONS_COLOR_RED
    252  f0b1		       85 09		      sta	COLUBK
      0  f0b3					      SLEEP	16	;; as we add more code for playfield, edit this.
      1  f0b3				   .CYCLES    SET	16
      2  f0b3
      3  f0b3				  -	      IF	.CYCLES < 2
      4  f0b3				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f0b3				  -	      ERR
      6  f0b3					      ENDIF
      7  f0b3
      8  f0b3				  -	      IF	.CYCLES & 1
      9  f0b3				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f0b3				  -	      nop	0
     11  f0b3				  -	      ELSE
     12  f0b3				  -	      bit	VSYNC
     13  f0b3				  -	      ENDIF
     14  f0b3				  -.CYCLES    SET	.CYCLES - 3
     15  f0b3					      ENDIF
     16  f0b3
     17  f0b3					      REPEAT	.CYCLES / 2
     18  f0b3		       ea		      nop
     17  f0b3					      REPEND
     18  f0b4		       ea		      nop
     17  f0b4					      REPEND
     18  f0b5		       ea		      nop
     17  f0b5					      REPEND
     18  f0b6		       ea		      nop
     17  f0b6					      REPEND
     18  f0b7		       ea		      nop
     17  f0b7					      REPEND
     18  f0b8		       ea		      nop
     17  f0b8					      REPEND
     18  f0b9		       ea		      nop
     17  f0b9					      REPEND
     18  f0ba		       ea		      nop
     19  f0bb					      REPEND
    254  f0bb		       a9 8d		      lda	#CONS_COLOR_TEAL
    255  f0bd		       85 09		      sta	COLUBK
      0  f0bf					      SLEEP	10
      1  f0bf				   .CYCLES    SET	10
      2  f0bf
      3  f0bf				  -	      IF	.CYCLES < 2
      4  f0bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f0bf				  -	      ERR
      6  f0bf					      ENDIF
      7  f0bf
      8  f0bf				  -	      IF	.CYCLES & 1
      9  f0bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f0bf				  -	      nop	0
     11  f0bf				  -	      ELSE
     12  f0bf				  -	      bit	VSYNC
     13  f0bf				  -	      ENDIF
     14  f0bf				  -.CYCLES    SET	.CYCLES - 3
     15  f0bf					      ENDIF
     16  f0bf
     17  f0bf					      REPEAT	.CYCLES / 2
     18  f0bf		       ea		      nop
     17  f0bf					      REPEND
     18  f0c0		       ea		      nop
     17  f0c0					      REPEND
     18  f0c1		       ea		      nop
     17  f0c1					      REPEND
     18  f0c2		       ea		      nop
     17  f0c2					      REPEND
     18  f0c3		       ea		      nop
     19  f0c4					      REPEND
    257  f0c4		       a9 c6		      lda	#CONS_COLOR_GREEN
    258  f0c6		       85 09		      sta	COLUBK
    259  f0c8		       e8		      inx
    260  f0c9		       88		      dey
    261  f0ca		       85 02		      sta	WSYNC
    262  f0cc		       d0 cc		      bne	Kernal_Tower_Draw
    263  f0ce				   Kernal_Tower_End
    264  f0ce		       a9 00		      lda	#CONS_COLOR_BLACK
    265  f0d0		       85 09		      sta	COLUBK
      0  f0d2					      CLEAR_PLAYFIELD
      1  f0d2		       a9 00		      lda	#%00000000
      2  f0d4		       85 0d		      sta	PF0
      3  f0d6		       85 0e		      sta	PF1
      4  f0d8		       85 0f		      sta	PF2
    267  f0da							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
    268  f0da		       a9 82		      lda	#CONS_COLOR_BLUE	; Make this a define
    269  f0dc		       85 08		      sta	COLUPF
    270  f0de		       a2 02		      ldx	#2	; this will always do +1 what you want
    271  f0e0		       86 84		      stx	loopIntI
    272  f0e2		       a9 f0		      lda	#%11110000
    273  f0e4				   Kernal_Stairs
    274  f0e4							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    275  f0e4							; This draws a nice staircase from our tower
    276  f0e4							; More background mumbo jumbo
    277  f0e4							; TODO -- allow drawing of player here
    278  f0e4		       a2 03		      ldx	#3	; this will always do +1 what you want
    279  f0e6		       86 85		      stx	loopIntJ
    280  f0e8				   Kernal_Stairs_J
    281  f0e8		       85 02		      sta	WSYNC
    282  f0ea		       85 0f		      sta	PF2
    283  f0ec		       c6 85		      DEC	loopIntJ
    284  f0ee		       10 f8		      BPL	Kernal_Stairs_J
    285  f0f0		       4a		      LSR
    286  f0f1		       4a		      LSR
    287  f0f2		       c6 84		      DEC	loopIntI
    288  f0f4		       10 ee		      BPL	Kernal_Stairs
    289  f0f6		       85 02		      sta	WSYNC
    290  f0f8
    291  f0f8							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    292  f0f8				   Kernal_Gap
    293  f0f8							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    294  f0f8							; This is just a spacing between the tiles
    295  f0f8							; we setup the presets for the complex stuff below!
    296  f0f8							; Maybe just make this part of the loop below? make my tile horizontal breaks 2 cycles each?
    297  f0f8
      0  f0f8					      CLEAR_PLAYFIELD
      1  f0f8		       a9 00		      lda	#%00000000
      2  f0fa		       85 0d		      sta	PF0
      3  f0fc		       85 0e		      sta	PF1
      4  f0fe		       85 0f		      sta	PF2
    299  f100		       85 02		      sta	WSYNC
    300  f102		       a9 00		      lda	#CONS_COLOR_BLACK	; May NEVER need to do this, there may be an inverse for the stairs above.
    301  f104		       85 08		      sta	COLUPF
    302  f106
    303  f106
    304  f106
    305  f106		       a9 10		      lda	#%00010000
    306  f108		       85 0d		      sta	PF0
    307  f10a		       a9 0c		      lda	#%00001100
    308  f10c		       85 0e		      sta	PF1
    309  f10e		       a9 e0		      lda	#%11100000
    310  f110		       85 0f		      sta	PF2
    311  f112
    312  f112		       a9 00		      lda	#0
    313  f114		       85 83		      sta	LineIdx
    314  f116		       a9 03		      lda	#3	; this will always do +1 what you want
    315  f118		       85 84		      sta	loopIntI
    316  f11a		       a2 00		      ldx	#0	; uused to change address levels
    317  f11c
    318  f11c		       85 02		      sta	WSYNC
    319  f11e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    320  f11e				   Kernal_CombatField
    321  f11e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    322  f11e		       a5 0f		      lda	CONS_TILE_HEIGHT
    323  f120		       85 85		      sta	loopIntJ
    324  f122				   Kernal_CombatField_startOfDraw
    325  f122		       85 02		      sta	WSYNC
    326  f124
    327  f124				   Kernal_CombatField_DrawPlayfied
    328  f124
    329  f124		       b5 87		      lda	p0_TileBooleans,x
    330  f126		       85 09		      sta	COLUBK
    331  f128
      0  f128					      SLEEP	20
      1  f128				   .CYCLES    SET	20
      2  f128
      3  f128				  -	      IF	.CYCLES < 2
      4  f128				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f128				  -	      ERR
      6  f128					      ENDIF
      7  f128
      8  f128				  -	      IF	.CYCLES & 1
      9  f128				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f128				  -	      nop	0
     11  f128				  -	      ELSE
     12  f128				  -	      bit	VSYNC
     13  f128				  -	      ENDIF
     14  f128				  -.CYCLES    SET	.CYCLES - 3
     15  f128					      ENDIF
     16  f128
     17  f128					      REPEAT	.CYCLES / 2
     18  f128		       ea		      nop
     17  f128					      REPEND
     18  f129		       ea		      nop
     17  f129					      REPEND
     18  f12a		       ea		      nop
     17  f12a					      REPEND
     18  f12b		       ea		      nop
     17  f12b					      REPEND
     18  f12c		       ea		      nop
     17  f12c					      REPEND
     18  f12d		       ea		      nop
     17  f12d					      REPEND
     18  f12e		       ea		      nop
     17  f12e					      REPEND
     18  f12f		       ea		      nop
     17  f12f					      REPEND
     18  f130		       ea		      nop
     17  f130					      REPEND
     18  f131		       ea		      nop
     19  f132					      REPEND
    333  f132
    334  f132		       b5 88		      lda	p0_TileBooleans,x+1
    335  f134		       85 09		      sta	COLUBK
    336  f136
      0  f136					      SLEEP	5	; minimal. mid is red atm.
      1  f136				   .CYCLES    SET	5
      2  f136
      3  f136				  -	      IF	.CYCLES < 2
      4  f136				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f136				  -	      ERR
      6  f136					      ENDIF
      7  f136
      8  f136					      IF	.CYCLES & 1
      9  f136					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f136		       04 00		      nop	0
     11  f138				  -	      ELSE
     12  f138				  -	      bit	VSYNC
     13  f138					      ENDIF
     14  f138				   .CYCLES    SET	.CYCLES - 3
     15  f138					      ENDIF
     16  f138
     17  f138					      REPEAT	.CYCLES / 2
     18  f138		       ea		      nop
     19  f139					      REPEND
    338  f139
    339  f139
    340  f139		       b5 8d		      lda	p1_TileBooleans,x
    341  f13b		       85 09		      sta	COLUBK
    342  f13d
      0  f13d					      SLEEP	10
      1  f13d				   .CYCLES    SET	10
      2  f13d
      3  f13d				  -	      IF	.CYCLES < 2
      4  f13d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f13d				  -	      ERR
      6  f13d					      ENDIF
      7  f13d
      8  f13d				  -	      IF	.CYCLES & 1
      9  f13d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f13d				  -	      nop	0
     11  f13d				  -	      ELSE
     12  f13d				  -	      bit	VSYNC
     13  f13d				  -	      ENDIF
     14  f13d				  -.CYCLES    SET	.CYCLES - 3
     15  f13d					      ENDIF
     16  f13d
     17  f13d					      REPEAT	.CYCLES / 2
     18  f13d		       ea		      nop
     17  f13d					      REPEND
     18  f13e		       ea		      nop
     17  f13e					      REPEND
     18  f13f		       ea		      nop
     17  f13f					      REPEND
     18  f140		       ea		      nop
     17  f140					      REPEND
     18  f141		       ea		      nop
     19  f142					      REPEND
    344  f142
    345  f142
    346  f142		       b5 8e		      lda	p1_TileBooleans,x+1
    347  f144		       85 09		      sta	COLUBK
    348  f146
      0  f146					      SLEEP	7
      1  f146				   .CYCLES    SET	7
      2  f146
      3  f146				  -	      IF	.CYCLES < 2
      4  f146				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f146				  -	      ERR
      6  f146					      ENDIF
      7  f146
      8  f146					      IF	.CYCLES & 1
      9  f146					      IFNCONST	NO_ILLEGAL_OPCODES
     10  f146		       04 00		      nop	0
     11  f148				  -	      ELSE
     12  f148				  -	      bit	VSYNC
     13  f148					      ENDIF
     14  f148				   .CYCLES    SET	.CYCLES - 3
     15  f148					      ENDIF
     16  f148
     17  f148					      REPEAT	.CYCLES / 2
     18  f148		       ea		      nop
     17  f148					      REPEND
     18  f149		       ea		      nop
     19  f14a					      REPEND
    350  f14a
    351  f14a		       a9 00		      lda	#CONS_COLOR_BLACK
    352  f14c		       85 09		      sta	COLUBK
    353  f14e
    354  f14e				   Kernal_CombatField_DrawPlayers
    355  f14e
      0  f14e					      DRAW_PLAYER	P0YPos, CONS_PLAYER_HEIGHT, GRP0, P0Ptr,P0Idx
      1  f14e				   .YPOS      SET	P0YPos
      2  f14e				   .HEIGHT    SET	CONS_PLAYER_HEIGHT
      3  f14e				   .PLAYER_REG SET	GRP0
      4  f14e				   .PLAYER_PTR SET	P0Ptr
      5  f14e				   .PLAYER_IDX SET	P0Idx
      6  f14e		       a4 9b		      ldy	.PLAYER_PTR
      7  f150		       a5 95		      lda	.YPOS
      8  f152		       e5 83		      SBC	LineIdx
      9  f154		       10 0b		      BPL	.skip
     10  f156		       c9 f2		      CMP	#.HEIGHT
     11  f158		       30 07		      BMI	.skip
     12  f15a		       b1 9b		      lda	(.PLAYER_PTR),y
     13  f15c		       e6 97		      inc	.PLAYER_IDX
     14  f15e		       4c 63 f1 	      jmp	.end
     15  f161				   .skip
     16  f161		       a9 00		      lda	#%0000000
     17  f163				   .end
     18  f163		       85 1b		      sta	.PLAYER_REG
      0  f165					      DRAW_PLAYER	P1YPos, CONS_PLAYER_HEIGHT, GRP1, P1Ptr,P1Idx
      1  f165				   .YPOS      SET	P1YPos
      2  f165				   .HEIGHT    SET	CONS_PLAYER_HEIGHT
      3  f165				   .PLAYER_REG SET	GRP1
      4  f165				   .PLAYER_PTR SET	P1Ptr
      5  f165				   .PLAYER_IDX SET	P1Idx
      6  f165		       a4 9d		      ldy	.PLAYER_PTR
      7  f167		       a5 96		      lda	.YPOS
      8  f169		       e5 83		      SBC	LineIdx
      9  f16b		       10 0b		      BPL	.skip
     10  f16d		       c9 f2		      CMP	#.HEIGHT
     11  f16f		       30 07		      BMI	.skip
     12  f171		       b1 9d		      lda	(.PLAYER_PTR),y
     13  f173		       e6 98		      inc	.PLAYER_IDX
     14  f175		       4c 7a f1 	      jmp	.end
     15  f178				   .skip
     16  f178		       a9 00		      lda	#%0000000
     17  f17a				   .end
     18  f17a		       85 1c		      sta	.PLAYER_REG
    358  f17c
    359  f17c				   Kernal_CombatField_EndOfDraw
    360  f17c		       e6 83		      inc	LineIdx
    361  f17e		       c6 85		      dec	loopIntJ
    362  f180		       d0 a0		      bne	Kernal_CombatField_startOfDraw
    363  f182
    364  f182		       85 02		      sta	WSYNC
    365  f184		       e8		      inx
    366  f185		       e8		      inx
    367  f186		       c6 84		      dec	loopIntI
    368  f188		       d0 94		      bne	Kernal_CombatField
    369  f18a
    370  f18a		       20 b2 f1 	      jsr	MoveJoystick
    371  f18d		       ea		      nop		;DEBUG! til i fill this out
    372  f18e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    373  f18e							; 29 lines of overscan
    374  f18e				   Overscan
    375  f18e							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      0  f18e					      TIMER_SETUP	29
      1  f18e				   .lines     SET	29
      2  f18e				   .cycles    SET	((.lines * 76) - 13)
      3  f18e
      4  f18e
      5  f18e				  -	      if	(.cycles % 64) < 12
      6  f18e				  -	      lda	#(.cycles / 64) - 1
      7  f18e				  -	      sta	WSYNC
      8  f18e					      else
      9  f18e		       a9 22		      lda	#(.cycles / 64)
     10  f190		       85 02		      sta	WSYNC
     11  f192					      endif
     12  f192		       8d 96 02 	      sta	TIM64T
      0  f195					      TIMER_WAIT
      1  f195				   .waittimer
      2  f195		       ad 84 02 	      lda	INTIM
      3  f198		       d0 fb		      bne	.waittimer
      4  f19a		       85 02		      sta	WSYNC
    378  f19c		       ea		      nop		; for debugging!
    379  f19d							; total = 262 lines, go to next frame
    380  f19d		       4c 3e f0 	      jmp	NextFrame
    381  f1a0							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    382  f1a0							; Subroutines
    383  f1a0							;;;;;;;;;;;;;;;;;;;;;
    384  f1a0							; SetHorizPos routine
    385  f1a0							; A = X coordinate
    386  f1a0							; X = player number (0 or 1)
    387  f1a0				   SetHorizPos
    388  f1a0		       85 02		      sta	WSYNC	; start a new line
    389  f1a2		       38		      sec		; set carry flag
    390  f1a3				   DivideLoop
    391  f1a3		       e9 0f		      sbc	#15	; subtract 15
    392  f1a5		       b0 fc		      bcs	DivideLoop	; branch until negative
    393  f1a7		       49 07		      eor	#7	; calculate fine offset
    394  f1a9		       0a		      asl
    395  f1aa		       0a		      asl
    396  f1ab		       0a		      asl
    397  f1ac		       0a		      asl
    398  f1ad		       95 10		      sta	RESP0,x	; fix coarse position
    399  f1af		       95 20		      sta	HMP0,x	; set fine offset
    400  f1b1		       60		      rts		; return to caller
    401  f1b2							;;;;;;;;;;;;;;;;;;;;;
    402  f1b2				   MoveJoystick
    403  f1b2							; Move vertically
    404  f1b2							; (up and down are actually reversed since ypos starts at bottom)
    405  f1b2		       a6 95		      ldx	P0YPos
    406  f1b4		       a9 20		      lda	#%00100000	;Up?
    407  f1b6		       2c 80 02 	      bit	SWCHA
    408  f1b9		       d0 05		      bne	SkipMoveUp
    409  f1bb		       e0 02		      cpx	#2
    410  f1bd		       90 01		      bcc	SkipMoveUp
    411  f1bf		       ca		      dex
    412  f1c0							;dex
    413  f1c0				   SkipMoveUp
    414  f1c0		       a9 10		      lda	#%00010000	;Down?
    415  f1c2		       2c 80 02 	      bit	SWCHA
    416  f1c5		       d0 05		      bne	SkipMoveDown
    417  f1c7		       e0 b7		      cpx	#183
    418  f1c9		       b0 01		      bcs	SkipMoveDown
    419  f1cb		       e8		      inx
    420  f1cc							;inx
    421  f1cc				   SkipMoveDown
    422  f1cc		       86 95		      stx	P0YPos
    423  f1ce							; Move horizontally
    424  f1ce		       a6 93		      ldx	P0XPos
    425  f1d0		       a9 40		      lda	#%01000000	;Left?
    426  f1d2		       2c 80 02 	      bit	SWCHA
    427  f1d5		       d0 05		      bne	SkipMoveLeft
    428  f1d7		       e0 10		      cpx	#16
    429  f1d9		       90 01		      bcc	SkipMoveLeft
    430  f1db		       ca		      dex
    431  f1dc				   SkipMoveLeft
    432  f1dc		       a9 80		      lda	#%10000000	;Right?
    433  f1de		       2c 80 02 	      bit	SWCHA
    434  f1e1		       d0 05		      bne	SkipMoveRight
    435  f1e3		       e0 99		      cpx	#153
    436  f1e5		       b0 01		      bcs	SkipMoveRight
    437  f1e7		       e8		      inx
    438  f1e8				   SkipMoveRight
    439  f1e8		       86 93		      stx	P0XPos
    440  f1ea		       60		      rts
    441  f1eb							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    442  f1eb							; Data
    443  f1eb							;;;;;;;;;;;;;;;;;;;;;
    444  f1eb				   PF_Kernal_Tower
    445  f1eb
    446  f1eb							; --- line 3
    447  f1eb		       f0		      .byte.b	#%11110000
    448  f1ec		       f7		      .byte.b	#%11110111
    449  f1ed		       7f		      .byte.b	#%01111111
    450  f1ee
    451  f1ee				   P0_Frame_0
    452  f1ee							; draw from top to bottom
    453  f1ee		       7c		      .byte.b	#%01111100
    454  f1ef		       7e		      .byte.b	#%01111110
    455  f1f0		       68		      .byte.b	#%01101000
    456  f1f1		       7c		      .byte.b	#%01111100
    457  f1f2		       3c		      .byte.b	#%00111100
    458  f1f3		       00		      .byte.b	#%00000000
    459  f1f4		       78		      .byte.b	#%01111000
    460  f1f5		       bd		      .byte.b	#%10111101
    461  f1f6		       be		      .byte.b	#%10111110
    462  f1f7		       5c		      .byte.b	#%01011100
    463  f1f8		       78		      .byte.b	#%01111000
    464  f1f9		       00		      .byte.b	#%00000000
    465  f1fa		       76		      .byte.b	#%01110110
    466  f1fb		       00		      .byte.b	#0
    467  f1fc				   P1_Frame_0
    468  f1fc							; draw from top to bottom
    469  f1fc		       3e		      .byte.b	#%00111110	; 0x3E
    470  f1fd		       7e		      .byte.b	#%01111110	; 0x7E
    471  f1fe		       16		      .byte.b	#%00010110	; 0x16
    472  f1ff		       3e		      .byte.b	#%00111110	; 0x3E
    473  f200		       3c		      .byte.b	#%00111100	; 0x3C
    474  f201		       00		      .byte.b	#%00000000	; 0x00
    475  f202		       1e		      .byte.b	#%00011110	; 0x1E
    476  f203		       bd		      .byte.b	#%10111101	; 0xBD
    477  f204		       7d		      .byte.b	#%01111101	; 0x7D
    478  f205		       3a		      .byte.b	#%00111010	; 0x3A
    479  f206		       1e		      .byte.b	#%00011110	; 0x1E
    480  f207		       00		      .byte.b	#%00000000	; 0x00
    481  f208		       6e		      .byte.b	#%01101110	; 0x6E
    482  f209		       00		      .byte.b	#0
    483  f20a							;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    484  f20a							; Epilogue
    485  f20a							;;;;;;;;;;;;;;;;;;;;;
    486  fffc					      org	$fffc
    487  fffc		       00 f0		      .word.w	Start	; reset vector
    488  fffe		       00 f0		      .word.w	Start	; BRK vector
